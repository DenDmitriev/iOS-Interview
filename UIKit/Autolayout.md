# Autolayout
Автоматическая компоновка является технологией создания UI интерфейсов на iOS и macOS. Его цель: облегчить вам создание пользовательских интерфейсов, которые автоматически адаптируются к различным размерам экрана и ориентации.

Положение и размер view относительно начала его superview определяются рамкой представления:
- Position: (frame.origin.x, frame.origin.y)
- Size: (frame.size.width, frame.size.height)

## Включение и отключение Autolayout
Все представления `view` при создании их в коде инициируются с помощью негибкой авторазмерной маски по умолчанию, так что для использования autolayout нам нужно указать свойство переключатель. Переключателем на каждом `view`, называется - `translatesAutoresizingMaskIntoConstraints`.
Положения:
- `myView.translatesAutoresizingMaskIntoConstraints = true` для устанавки размера и положения `view` традиционным способом, через свойства frame и center.
- `myView.translatesAutoresizingMaskIntoConstraints = false` для установки размера и положения `view` спомощью ограничений (сonstraints).

> Дословный первод: перевести маску автоматического изменения размера в ограничения или позволить устанавливать рамку вручную.

Представлений, которые вы создаете в Interface Builder, translateAutoresizingMaskIntoConstraints по умолчанию устанавливается в false, 
Представлений, которые вы создаете в коде, свойство устанавливается в true.


## Ограничения (Constraints)
Ограничения (Constraints) являются основной концепцией автоматического макета. Вместо того, чтобы указывать фреймы каждого из ваших представлений вручную:
```swift
myView.frame = .init(x: 10, y: 10, width: 120, height: 40)
```
вы выражаете макет семантически с ограничениями. Семантически означает, что вы просто записываете свое реальное намерение, а не жестко закодированные числа. Чтобы описать ограничения макета, мы используем якоря (anchors). Они описывают либо конкретную позицию, либо измерение представления и могут быть сгруппированы в три категории:

### Базовые якоря
Горизонтальный (x):
- leading
- trailing
Вертикальный (y):
- top
- bottom


### Выведенные якоря
Размер:
- width = |trailing — leading|
- height = |bottom — top|
Центр:
- centerX = ½ (leading + trailing)
- centerY = ½ (top + bottom)


### Якоря Макета Текста
Базовая линия (только для представлений, отображаютых текст):
- firstBaseline
- lastBaseline

Все эти якоря макета (за исключением последних двух, которые работают только для UILabels и UITextViews) определены на каждом экземпляре UIView, поэтому вы можете легко добавить ограничения, установив один якорь макета в отношении к другому, например:
```swift
okButton.top = titleLabel.bottom
```
Для размещения okButton непосредственно под titleLabel.

### Уравнение Ограничения
Как правило, ограничение является линейным уравнением и может иметь множитель (multiplier) и смещение, обозначенное константой (constant).
```swift
anchor2 = multiplier × anchor1 + constant
```

### Авторазмерная маска (The Autoresizing Mask)
До внедрения Auto Layout разработчикам было трудно сделать макеты действительно адаптивными, но уже был полезный инструмент для некоторых базовых "волшебных" автоматических размеров: Авторазмерная маска (The Autoresizing Mask). Как следует из названия - авторазмерная маска состоит из нескольких флагов, указывающих, следует ли и как-либо изменять размер представления при изменении размера его superview. Существует шесть доступных вариантов параметров`UIViewAutoresizing`:
Горизонтальные Поля:
- flexibleLeftMargin
- flexibleRightMargin
Вертикальные поля:
- flexibleTopMargin
- flexibleBottomMargin
Размер:
- flexibleWidth
- flexibleHeight

![0*jj-0uxZKq6cAZbY](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/8addba55-bf63-4bbb-9f1d-7da787b25e52)

```swift
myView.autoresizingMask = [.flexibleWidth,
                           .flexibleTopMargin,
                           .flexibleBottomMargin]
```

Гибкие параметры размеров (гибкая ширина и гибкая высота) действуют как пружины, когда они включены: они делают масштаб вида пропорционально его superview по отношению к конкретному измерению. Если кнопка занимает 80% ширины супервида, а ширина супервида удваивается в какой-то момент времени, то ширина кнопки также удваивается.

### Приоритеты Макета
Чтобы обеспечить более сложные макеты, каждое ограничение имеет приоритет. Определительность представлена цело числом в диапазоне от 1 до 1000. Чем выше приоритет, тем важнее ограничение.

При создании нового ограничения ему по умолчанию присваивается приоритет 1000. Что озночает что оно должно быть удовлетворено при разрешении спорных ограничений согалсно приоритету. Если есть какие-либо противоречивые ограничения, которые также необходимы, ваш макет сломается.

Пример:
У вас есть кнопка, которая должна быть шириной 300 пт. Тем не менее, для вас очень важно, чтобы ширина кнопки никогда не превышала ширину ее супервида. Таким образом, вы создаете для этого два ограничения:

```swift
button.width = 300 // приоритет: 999
button.width <= superview.width // приоритет: 1000
```

Последнее требование более важно для вас, поэтому вы сохраняете его в качестве обязательного ограничения (приоритет = 1000), но вы уменьшаете приоритет первого ограничения, чтобы позволить движку компоновки разорвать это ограничение в случае, если суперпросмотр кнопки меньше 300 пунктов.

#### Приоритеты по умолчанию
- UILayoutPriority.required // 1000
- UILayoutPriority.defaultHigh // 750
- UILayoutPriority.defaultLow // 250

### Размер Внутренного Контента (The Intrinsic Content Size)
Это естественный размер вида, размер, который он предпочитает принимать. Это свойство на UIView, которое может быть переопределено в любом подклассе.
Нет ничего волшебного в размере контента. Ну, почти. Важно знать, что во время каждого прохода макета система создает ограничения для размера содержимого. Эти ограничения являются необязательными. Таким образом, они применяются только тогда, когда вы не добавляете никаких ограничений (с более высоким приоритетом), которые приведут к другому размеру.
Пример:
- UISwitch (49, 31)
- UIActivityIndicator (20, 20)

И это сила размера содержимого: если вы ограничиваете только положение представления, но не его размер, он автоматически примет его размер содержимого. Если вы также ограничите его размер, ваше ограничение будет преобладать, не вызывая конфликта.

### Сопротивление растежению и сжатию контента (Hugging & Compression Resistance)
Размер Внутренного Контента на самом деле представлен двумя ограничениями неравенства:

![sdafs](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/ff05c8d7-d827-417d-8b0c-d297621ffbfb)

- Первое ограничение (со знаком >=) называется сопротивлением сжатию, потому что оно говорит о том, что ширина представления не должна быть меньше его внутреннего содержимого.
- Второе ограничение (со знаком <=) называется растежением контента, потому что оно говорит, что ширина представления не должна быть больше его внутренней ширины содержимого.

Эти имена имеют смысл, потому что, по сути, первое ограничение "подталкивает" границы вида изнутри и, таким образом, противодействует любой попытке сжать его, в то время как второе ограничение тянет границы вида к его центру, как если бы оно обнимало его содержание.

![cs](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/64a8cf53-be5e-4279-952b-b4b90002c6e2)

В большинстве случаев это приемлемо, если представление больше, чем его внешний размер контента, потому что вся информация, которую он показывает, все еще видна. С другой стороны, обычно плохо, если представление меньше, чем его внешне размер содержимого, потому что в этом случае некоторая важная информация может быть отключена.

По этой причине приоритет ограничения сопротивления сжатию больше, чем приоритет ограничения объятия контента по умолчанию:
- Сопротивление Сжатию Приоритет По Умолчанию = UILayoutPriority.defaultHigh(750)
- Приоритет по умолчанию для растежения содержимым = UILayoutPriority.defaultLow(250)

Поскольку эти ограничения на растежение и сопротивление сжатию контента (также называемые CHCR) создаются только во время выполнения внутри, вы не можете установить их приоритеты напрямую. Вместо этого вы можете установить их с помощью методов доступа UIView
```swift
setContentHuggingPriority(_: UILayoutPriority, 
                        for: UILayoutConstraintAxis)
```
и
```swift
setContentCompressionResistancePriority(_: UILayoutPriority, 
                                      for: UILayoutConstraintAxis)
```

Источники:
- [The Auto Layout Comprehendium](https://medium.com/@PhiJay/the-auto-layout-comprehendium-%EF%B8%8F-6d7e2105bf70)
