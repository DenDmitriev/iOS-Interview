# Многопоточность (concurrency)


## Уровни абстракции над многопоточностью
Для лучшего понимания многопоточности (concurrency), Apple ввела некоторые абстрактные понятия, с которыми оперируют оба инструмента — GCD и Operation. 

### Очередь (queue)
Очереди (queues) — это обычные очереди, в которые выстраиваются люди, чтобы купить, например, билет в кинотеатр, но в нашем случае в очередь выстраиваются замыкания (closure — анонимные блоки кода). Система просто выполняет их согласно очереди, “выдергивая” следующего по очереди и запуская его на выполнение в соответствующем этой очереди потоке. Очереди (queues) следуют FIFO паттерну (First In, First Out), это означает, что тот, кто первым был поставлен в очередь, будет первым направлен на выполнение. У вас может быть множество очередей (queues) и система “выдергивает” замыкания по одному из каждой очереди и запускает их на выполнение в их собственных потоках. Таким образом, вы получаете многопоточность.

Но это лишь общее представление о том, как многопоточность (сoncurrency) работает в iOS. Интрига заключается в том, что собой представляют эти очереди в смысле выполнения заданий по отношению друг к другу (последовательное или параллельное) и с помощью какой функции (синхронной или асинхронной) эти задания помещаются в очередь, тем самым блокируя или не блокируя текущую очередь.

Типы очередей:
- Последовательные (serial)
- Параллельные (concurrent)

<img width="400" alt="Снимок экрана 2024-02-08 в 07 30 31" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/96a7818d-5d0a-4090-9a94-083b873f76d9">


Последовательные очереди (​serial queues)​ «вытягивают» задание (замыкание), которое находится в начале очереди, и дают ему работать до завершения, а затем приступают к следующему.

Параллельные очереди (​concurrent queues)​ тоже берут в работу задание спереди, запуская его в определенном потоке. Если у системы есть ещё ресурсы, она сразу приступает к следующему заданию из очереди, посылая его в другой поток, в то время как первая функция ещё работает. Так система может «вытянуть» целый ряд задач.

### Синхронное и асинхронное выполнение заданий
Как только очередь (queue) создана, задание на ней можно разместить с помощью двух функций: 
- sync — синхронное выполнение по отношению к текущей очереди
- async — асинхронное выполнение по отношению к текущей очереди.

Синхронная функция sync возвращает управление на текущую очередь только после полного завершения задания, тем самым блокируя текущую очередь:

<img width="600" alt="49fda33d32be4a6ebb511bf0530a8854" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/a9cc20f2-4851-4377-9a4e-4848bfe5e809">

Асинхронная функция async, в противоположность функции sync, возвращает управление на текущую очередь немедленно после запуска задания на выполнение в другой очереди, не ожидая его завершения. Таким образом, асинхронная функция async не блокирует выполнение заданий на текущей очереди:

<img width="600" alt="c32c597b60d24ae69f5fffe4ca155d9c" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/cf0360af-8ec8-4653-a291-ff0affca32c7">

В случае асинхронного выполнения последовательная (serial) очередь запускается паралельным потоком по отношению к текущему потоку

<img width="600" alt="cfc0fb700a034acbab2cc25fc6e14f17" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/490a50f3-b1df-4652-ad9a-83c1855ecd77">

А параллельная (concurrent) очередь запускается множественными паралельными потоками по отношению к текущему потоку

<img width="600" alt="3919fb1ff81747dca78feabb45e3a9de" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/ee9fcc7b-5857-451d-9a9d-33f51e0772b8">

### Как запустить
Задача разработчика состоит только в выборе очереди и добавлении задания (как правило, замыкания), например в главную очередь синхронно с помощью функции `DispatchQueue​.main.sync` или асинхронно с помощью функции `DispatchQueue​.main.async`, дальше работает исключительно iOS.

Заметьте, что переключение затратных заданий с Main queue на другой поток всегда АСИНХРОННО. НИКОГДА НЕ вызывайте метод sync на Main queue, потому что это приведет к deadlock вашего приложения!

#### Как создать очередь
Помимо пользовательских очередей, которые нужно специально создавать, система iOS предоставляет в распоряжение разработчика готовые (out-of-the-box) глобальные очереди (queues). Их 5:
- **Последовательная очередь Main queue**, в которой происходят все операции с пользовательским интерфейсом (UI) 
```swift
let main = DispatchQueue.main
```
- **Параллельные 4 фоновые concurrent глобальных очереди** разными приоритетами выполнения
```swift
// наивысший приоритет
let userInteractiveQueue = DispatchQueue.global(qos: .userInteractive)

let userInitiatedQueue = DispatchQueue.global(qos: .userInitiated)

let utilityQueue = DispatchQueue.global(qos: .utility)

// самый низкий приоритет
let backgroundQueue = DispatchQueue.global(.background) 

// по умолчанию
// используется qos между .userInitiated и .utility.
let defaultQueue = DispatchQueue.global()
```

Каждую из этих очередей Apple наградила абстрактным «качеством обслуживания» qos (сокращение для Quality of Service), и мы должны решить, каким оно должно быть для наших заданий.

> Важно понимать, что все эти глобальные очереди являются СИСТЕМНЫМИ глобальными очередями и наши задания — не единственные задания в этой очереди! Также важно знать, что все глобальные очереди, кроме одной, являются concurrent (параллельными) очередями

## Проблемы многопоточности
Как только мы позволяем задачам (tasks) работать параллельно, появляются проблемы, связанные с тем, что разные задачи захотят получить доступ к одним и тем же ресурсам.
Основных проблемы три:
- cостояние гонки (race condition)
- инверсия приоритетов (priority inversion)
- взаимная блокировка (deadlock) — ситуация в многопоточной системе, при которой несколько потоков находятся в состоянии бесконечного ожидания ресурсов, занятых самими этими потоками

### Состояние гонки (race condition)
ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода

![multithreaded_testing](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/cdabdb53-ab76-4f2a-853f-a0fdb7d4e324)

### Инверсия приоритетов (priority inversion)

Допустим в системе существуют две задачи с низким (А) и высоким (Б) приоритетом. В момент времени T1 задача (А) блокирует ресурс и начинает его обслуживать. В момент времени T2 задача (Б) вытесняет низкоприоритетную задачу (А) и пытается завладеть ресурсом в момент времени T3. Но так как ресурс заблокирован, задача (Б) переводится в ожидание, а задача (А) продолжает выполнение. В момент времени Т4 задача (А) завершает обслуживание ресурса и разблокирует его. Так как ресурс ожидает задача (Б), она тут же начинает выполнение.
Временной промежуток (T4-T3) называют ограниченной инверсией приоритетов. В этом промежутке наблюдается логическое несоответствие с правилами планирования — задача с более высоким приоритетом находится в ожидании в то время как низкоприоритетная задача выполняется.

<img width="588" alt="2a40815749274c3897e581524cc2f539" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/5e496e03-b225-4fde-b64b-533ece56ed6d">

### Взаимная блокировка (deadlock)
Взаимная блокировка — это аварийное состояние системы, которое может возникать при вложенности блокировок ресурсов. 
Например если мы запустим этот код то получим в консоли только ангела. Всякая **последовательная очередь** ждёт выполнения текущей задачи, перед тем как начать выполнять следующую. Когда мы пытаемся СИНХРОННО поставить в очередь текущую задачу, мы получаем блокировку. Это происходит потому, что когда мы выполняем код с чертиком, то мы это делаем в рамках текущей, уже выполняющейся в очереди задачи И пытаемся синхронно добавить задачу. Синхронно означает, что мы должны дождаться завершения текущей задачи. Но как мы можем завершить задачу в которой мы находимся, если мы сами её и тормозим? Это и называется взаимной блокировкой. Ангел ждёт выполнения чертика, а чертик ждёт завершения работы всего блока замыкания ангела с флагом финиша.
```swift
let serialQueue = DispatchQueue(label: "my.queue")
serialQueue.async {
    print("😇") 
    serialQueue.sync { // deadlock
        print("😈")
    }
    print("🏁")
}
// 😇
// deadlock 
```
Чтоб избежать этого, можно указать тип очереди как паралельный
```swift
let concurrentQueue = DispatchQueue(label: "my.queue", attributes: .concurrent)
concurrentQueue.async {
    print("😇")
    concurrentQueue.sync {
        print("😈")
    }
    print("🏁")
}
// 😇
// 😈
// 🏁
```
Что насчет главной очереди, которая является **последовательной**? Запуская вложеный код синхронно мы получаем тоже блокировку, но неявно:
```swift
print("😇")
DispatchQueue.main.sync {  // error: Execution was interrupted, reason: EXC_BREAKPOINT (code=1, subcode=0x1837e8028). Процесс остался в том месте, где он был прерван.
    print("😈")
}
print("🏁")
// 😇
// deadlock неявно
```
Взаимной блокировки можно избежать, если не использовать вложенность, или если ресурс использует протокол увеличения приоритета.

> НИКОГДА НЕ вызывайте метод sync на main queue, потому что это приведет к взаимной блокировке (deadlock) вашего приложения!
