# Autolayout
Автоматическая компоновка является технологией создания UI интерфейсов на iOS и macOS. Его цель: облегчить вам создание пользовательских интерфейсов, которые автоматически адаптируются к различным размерам экрана и ориентации.

Положение и размер view относительно начала его superview определяются рамкой представления:
- Position: (frame.origin.x, frame.origin.y)
- Size: (frame.size.width, frame.size.height)

## Включение и отключение Autolayout
Все представления `view` при создании их в коде инициируются с помощью негибкой авторазмерной маски по умолчанию, так что для использования autolayout нам нужно указать свойство переключатель. Переключателем на каждом `view`, называется - `translatesAutoresizingMaskIntoConstraints`.
Положения:
- `myView.translatesAutoresizingMaskIntoConstraints = true` для устанавки размера и положения `view` традиционным способом, через свойства frame и center.
- `myView.translatesAutoresizingMaskIntoConstraints = false` для установки размера и положения `view` спомощью ограничений (сonstraints).

> Дословный первод: перевести маску автоматического изменения размера в ограничения или позволить устанавливать рамку вручную.

Представлений, которые вы создаете в Interface Builder, translateAutoresizingMaskIntoConstraints по умолчанию устанавливается в false, 
Представлений, которые вы создаете в коде, свойство устанавливается в true.


## Ограничения (Constraints)
Ограничения (Constraints) являются основной концепцией автоматического макета. Вместо того, чтобы указывать фреймы каждого из ваших представлений вручную:
```swift
myView.frame = .init(x: 10, y: 10, width: 120, height: 40)
```
вы выражаете макет семантически с ограничениями. Семантически означает, что вы просто записываете свое реальное намерение, а не жестко закодированные числа. Чтобы описать ограничения макета, мы используем якоря (anchors). Они описывают либо конкретную позицию, либо измерение представления и могут быть сгруппированы в три категории:

### Базовые якоря
Горизонтальный (x):
- leading
- trailing
Вертикальный (y):
- top
- bottom


### Выведенные якоря
Размер:
- width = |trailing — leading|
- height = |bottom — top|
Центр:
- centerX = ½ (leading + trailing)
- centerY = ½ (top + bottom)


### Якоря Макета Текста
Базовая линия (только для представлений, отображаютых текст):
- firstBaseline
- lastBaseline

Все эти якоря макета (за исключением последних двух, которые работают только для UILabels и UITextViews) определены на каждом экземпляре UIView, поэтому вы можете легко добавить ограничения, установив один якорь макета в отношении к другому, например:
```swift
okButton.top = titleLabel.bottom
```
Для размещения okButton непосредственно под titleLabel.

### Уравнение Ограничения
Как правило, ограничение является линейным уравнением и может иметь множитель (multiplier) и смещение, обозначенное константой (constant).
```swift
anchor2 = multiplier × anchor1 + constant
```

### Авторазмерная маска (The Autoresizing Mask)
До внедрения Auto Layout разработчикам было трудно сделать макеты действительно адаптивными, но уже был полезный инструмент для некоторых базовых "волшебных" автоматических размеров: Авторазмерная маска (The Autoresizing Mask). Как следует из названия - авторазмерная маска состоит из нескольких флагов, указывающих, следует ли и как-либо изменять размер представления при изменении размера его superview. Существует шесть доступных вариантов параметров`UIViewAutoresizing`:
Горизонтальные Поля:
- flexibleLeftMargin
- flexibleRightMargin
Вертикальные поля:
- flexibleTopMargin
- flexibleBottomMargin
Размер:
- flexibleWidth
- flexibleHeight

![0*jj-0uxZKq6cAZbY](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/8addba55-bf63-4bbb-9f1d-7da787b25e52)

```swift
myView.autoresizingMask = [.flexibleWidth,
                           .flexibleTopMargin,
                           .flexibleBottomMargin]
```

Гибкие параметры размеров (гибкая ширина и гибкая высота) действуют как пружины, когда они включены: они делают масштаб вида пропорционально его superview по отношению к конкретному измерению. Если кнопка занимает 80% ширины супервида, а ширина супервида удваивается в какой-то момент времени, то ширина кнопки также удваивается.

### Приоритеты Макета
Чтобы обеспечить более сложные макеты, каждое ограничение имеет приоритет. Определительность представлена цело числом в диапазоне от 1 до 1000. Чем выше приоритет, тем важнее ограничение.

При создании нового ограничения ему по умолчанию присваивается приоритет 1000. Что озночает что оно должно быть удовлетворено при разрешении спорных ограничений согалсно приоритету. Если есть какие-либо противоречивые ограничения, которые также необходимы, ваш макет сломается.

Пример:
У вас есть кнопка, которая должна быть шириной 300 пт. Тем не менее, для вас очень важно, чтобы ширина кнопки никогда не превышала ширину ее супервида. Таким образом, вы создаете для этого два ограничения:

```swift
button.width = 300 // приоритет: 999
button.width <= superview.width // приоритет: 1000
```

Последнее требование более важно для вас, поэтому вы сохраняете его в качестве обязательного ограничения (приоритет = 1000), но вы уменьшаете приоритет первого ограничения, чтобы позволить движку компоновки разорвать это ограничение в случае, если суперпросмотр кнопки меньше 300 пунктов.

#### Приоритеты по умолчанию
- UILayoutPriority.required // 1000
- UILayoutPriority.defaultHigh // 750
- UILayoutPriority.defaultLow // 250

### Размер Внутренного Контента (The Intrinsic Content Size)
Это естественный размер вида, размер, который он предпочитает принимать. Это свойство на UIView, которое может быть переопределено в любом подклассе.
Нет ничего волшебного в размере контента. Ну, почти. Важно знать, что во время каждого прохода макета система создает ограничения для размера содержимого. Эти ограничения являются необязательными. Таким образом, они применяются только тогда, когда вы не добавляете никаких ограничений (с более высоким приоритетом), которые приведут к другому размеру.
Пример:
- UISwitch (49, 31)
- UIActivityIndicator (20, 20)

И это сила размера содержимого: если вы ограничиваете только положение представления, но не его размер, он автоматически примет его размер содержимого. Если вы также ограничите его размер, ваше ограничение будет преобладать, не вызывая конфликта.

### Сопротивление растежению и сжатию контента (Hugging & Compression Resistance)
Размер Внутренного Контента на самом деле представлен двумя ограничениями неравенства:

![sdafs](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/ff05c8d7-d827-417d-8b0c-d297621ffbfb)

- Первое ограничение (со знаком >=) называется сопротивлением сжатию, потому что оно говорит о том, что ширина представления не должна быть меньше его внутреннего содержимого.
- Второе ограничение (со знаком <=) называется растежением контента, потому что оно говорит, что ширина представления не должна быть больше его внутренней ширины содержимого.

Эти имена имеют смысл, потому что, по сути, первое ограничение "подталкивает" границы вида изнутри и, таким образом, противодействует любой попытке сжать его, в то время как второе ограничение тянет границы вида к его центру, как если бы оно обнимало его содержание.

![cs](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/64a8cf53-be5e-4279-952b-b4b90002c6e2)

В большинстве случаев это приемлемо, если представление больше, чем его внешний размер контента, потому что вся информация, которую он показывает, все еще видна. С другой стороны, обычно плохо, если представление меньше, чем его внешне размер содержимого, потому что в этом случае некоторая важная информация может быть отключена.

По этой причине приоритет ограничения сопротивления сжатию больше, чем приоритет ограничения объятия контента по умолчанию:
- Сопротивление Сжатию Приоритет По Умолчанию = UILayoutPriority.defaultHigh(750)
- Приоритет по умолчанию для растежения содержимым = UILayoutPriority.defaultLow(250)

Поскольку эти ограничения на растежение и сопротивление сжатию контента (также называемые CHCR) создаются только во время выполнения внутри, вы не можете установить их приоритеты напрямую. Вместо этого вы можете установить их с помощью методов доступа UIView
```swift
setContentHuggingPriority(_: UILayoutPriority, 
                        for: UILayoutConstraintAxis)
```
и
```swift
setContentCompressionResistancePriority(_: UILayoutPriority, 
                                      for: UILayoutConstraintAxis)
```

### Обновление макета
Что происходит за кулисами, так это то, что система решает набор линейных уравнений составленный из ограничений (constraints) для нас. Это называется пропуском макета (The Layout Pass). Из-за того, что ограничения могут иметь разные приоритеты, механизм компоновки не может решить все линейные уравнения одновременно. Фактически, он следует этому алгоритму:
1. Start with the highest priority = 1000.
2. Решите все ограничения с одинаковым priority.
3. Является ли макет неоднозначным?
   - Да:
        → priority −= 1
        → Перейдите к шагу 2.
   - Нет:
        → Макет завершен (возврат)

Понимание этого алгоритма означает понимание того, как работает приоритет. Многие разработчики считают, что ограничение с приоритетом < 1000 все еще влияет на макет, даже если макет не является двусмысленным. Это не так: как только вычисляемый макет не является двусмысленным, все ограничения с более низким приоритетом просто игнорируются.
Если вы настроили весь свой макет в Interface Builder, вам не нужно беспокоиться о том, когда именно выкладывается ваш вид. Все это происходит "автомагически". Однако, если вам нужно настроить части (или все) вашего макета в коде, полезно знать, когда запускается пропуск макета.
Тем не менее, некоторые действительно причудливые макеты могут потребовать некоторой настройки, и если вам нужно это сделать, правильное место находится внутри layoutSubviews(), после вызова суперреализации:
![1*TEgSNr01iSX0eIPR4jh3QA@2](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/0f2afd22-4ac6-4ede-98d8-beb687201306)
```swift
override func layoutSubviews() {
    // Пусть механизм компоновки решит ваши ограничения (constraints):
    super.layoutSubviews()
    // Теперь вы можете вручную менять рамки frame любого подпредставления.
    // Рамка непосредственного view установлена правильно.
    // Так что в случае, если вам нужно выполнить какие-либо расчеты, основанные на размере вида, это место для этого.
}
```
Именно здесь происходит "магия": layoutSubviews() просматривает все ограничения, которые влияют на размер любого подпросмотра, и преобразует их в реальные рамки.

#### Управление обновлением макета
Когда вы меняете макет своего представления, вы обычно выполняете несколько шагов для достижения желаемого результата. Например, вы можете:
- убрать ограничение
- добавить новое ограничение
- добавить новое view в иерархию
- ограничить subview в пределах своего superview

Все эти шаги потребуют пересчета вашего макета. По этой причине UIKit не сразу запускает новый макет, когда что-то в ваших изменениях, потому что это было бы неэффективно. Вместо этого ваш макет помечается как недействителен флагом `needsLayout`. Это происходит всякий раз, когда
- вы добавляете или удаляете ограничения
- вы изменяете существующие ограничения
- вы добавляете или удаляете представление из иерархии представлений

Недействительность макета означает, поднят ли `needsLayout` флаг (т.е. он установлен в true). Во время цикла компоновки, система проверяет этот флаг, и запускает обновление макета если флаг true.

![1*VelsyFElFaIhh80GZC71-w@2x](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/00010836-0f2f-4e70-8488-e9cccaa251d7)

Этот флаг является для UIKit внутренним, поэтому как разработчик у вас нет прямого доступа к нему. Это имеет смысл, потому что вам никогда не нужно обновлять его самостоятельно. Он автоматически устанавливается в false после завершения пропуска макета. Чтоб пометить макет недействительным у нас есть методы:
- `setNeedsLayout()` Это пометит ваш макет как недействительный, и, таким образом, ваш макет будет пересобран в следующем цикле (т.е. будет вызван layoutSubviews()).
- `layoutIfNeeded()` Макет будет пересчитан тут же, но только в том случае, если он был ранее признан недействительным (либо системой, либо путем вызова setNeedsLayout()).

> ⚠️ Вы никогда не должны сами называть layoutSubviews()). Вместо этого используйте `layoutIfNeeded()` или `layoutIfNeeded()`, если вам нужно принудительно немедленно пройти макет и при необходимости сделать макет недействительным.

#### Устовка ограничений
Это распространенное недоразумение среди разработчиков iOS, что вам нужно вызвать updateConstraints() или updateConstraintsIfNeeded() после того, как вы добавили или изменили какие-либо из ваших ограничений. Увы нет. На самом деле, эти методы дают вам возможность добавлять, удалять или изменять ограничения в пакетном виде. В 99% случаев вам не нужно этого делать. Обычно вы должны обновлять ограничения сразу после изменения. В документации Apple говорится: Если вы хотите изменить ограничение в ответ на нажатие кнопки, внесите это изменение непосредственно в методе действия кнопки.

Причина в том, что это значительно облегчает понимание потока управления и приведет к более чистому коду. В некоторых (редких) случаях это может быть слишком медленно, например, когда вам нужно:
- изменить огромное количество ограничений одновременно или
- избыточно включать и выключать одни и те же ограничения несколько раз подряд

Если это так, вам следует переключиться на другую парадигму и обновить все свои ограничения в пакете. Для этого вам нужно переопределить метод updateConstraints() и выполнить все изменения в ваших ограничениях. Это даст лучшую производительность, так как механизм компоновки более эффективен, когда он подает все изменения сразу.

Источники:
- [The Auto Layout Comprehendium](https://medium.com/@PhiJay/the-auto-layout-comprehendium-%EF%B8%8F-6d7e2105bf70)
