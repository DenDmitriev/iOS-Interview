# ARC и управление памятью

## Что такое ARC?
Теперь же в Swift используется ARC подход, который выделяет и высвобождения память автоматически. В рамках этого метода вам не нужно использовать `release` и `retain`.
Основная концепция ARC очень проста: когда объект сохраняется в памяти, то счетчик ссылок инкрементируется, а высвобождается, когда происходит декремент этого счетчика.

В swift с ARC мы в основном используем `strong` (сильные), ``weak (слабые) и `unowned` ссылки.
Если счетчик ссылок станет равным нулю, то объект будет удален из памяти.
Что из себя представляет жизненный цикл объекта?
1. Выделение памяти (аллокация): берет память из стека или кучи.
2. Инициализация: выполняется init-код
3. Эксплуатация: объект используется
4. Деинициализация: выполняется deinit-код
5. Высвобождение памяти (деаллокация): память возвращается стеку или куче обратно.

## Какие могут возникать проблемы в рамках управления памятью?
 - Освобождение или перезапись данных, когда объект еще используется. Это вызывает сбой или повреждение данных.
 - Объект не высвобожден, когда он уже не используется. Это приводит к утечке памяти.

## Сбои в приложении.
Что такое утечка памяти (memory leak)?
Когда выделенная под объект память не освобождается, хоть сам объект уже больше никогда не будет использоваться, это называется утечкой памяти. Это часто происходит, когда два объекта ссылаются друг на друга, что делает невозможным их высвобождение.
Утечки памяти в приложении приводят к снижению производительности системы из-за увеличения объема потребляемой памяти.

![5695fe9af988d01523e422ad587ece9a](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/a57771f5-91c4-4928-8ea4-6d3b30ec09fd)

Ниже приведен пример того, как сильный ссылочный цикл может быть создан по ошибке. В этом примере мы определяем два класса Person и Apartment, которые создают модель блока квартир с их жителями:

```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) освобождается") }
}
 
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Апартаменты \(unit) освобождаются") }
}
```

Следующий фрагмент кода определяет две опциональные переменные с именами john и unit4A, которые будут назначены определенным экземплярам классов Apartment и Person. Оба значения переменных равны nil, в силу того, что они опциональны:

```swift
var john: Person?
var unit4A: Apartment?
```

Теперь вы можете создать свои экземпляры Person и Apartment и присвоить их этим переменным john, unit4A:

```swift
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
```

Вот как выглядят сильные связи после того создания и присваивания этих двух экземпляров. Переменная john имеет сильную связь с экземпляром класса Person, переменная unit4A имеет сильную связь с экземпляром Apartment:

<img width="1267" alt="referenceCycle01_2x" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/8d397d18-7b8f-44de-9599-2cc2dafe2a37">

Теперь вы можете соединить эти два экземпляра вместе, так что житель будет иметь апартаменты, а апартаменты будут иметь своих жителей. Обратите внимание, что восклицательный знак (!) используется для развертывания и допуска к экземплярам, хранимым в опциональных переменных john, unit4A, так что установить значения свойством можно в такой форме:

```swift
john!.apartment = unit4A
unit4A!.tenant = john
```
Вот как выглядят сильные связи после того, как мы соединили экземпляры:
<img width="1266" alt="referenceCycle02_2x" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/59841303-68ee-4a83-8de8-c8520d0c87f6">

К сожалению, соединяя таким образом, образуется цикл сильных ссылок между экземплярами. Экземпляр Person имеет сильную ссылку на экземпляр Apartment, экземпляр Apartment имеет сильную ссылку на экземпляр Person. Таким образом, когда вы разрушаете сильные ссылки, принадлежащие переменным john и unit4A, их количество все равно не падает до нуля, и экземпляры не освобождаются:

```swift
john = nil
unit4A = nil
```

Обратите внимание, что ни один деинициализатор не был вызван, когда вы присваивали nil. Цикл сильных ссылок предотвратил экземпляры Person и Apartment от освобождения, что вызывает утечку памяти в вашем приложении.
Вот как выглядят сильные ссылки после того, как вы присвоили nil переменным, john, unit4A:
<img width="1261" alt="referenceCycle03_2x" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/a853e714-f09a-4a37-a97e-41c8b3a9f5c9">
Сильные взаимные ссылки остались между экземплярами Person и Apartment и не могут быть разрушены.

### Слабые (weak) ссылки

Для автоматического удаления объектов нужно сделать исправление. В этот раз свойство tenant экземпляра класса Apartment объявлено как слабая ссылка:
```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) деинициализируется") }
}
 
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) деинициализируется") }
}

var john: Person?
var unit4A: Apartment?
 
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
 
john!.apartment = unit4A
unit4A!.tenant = john
```
Вот как теперь выглядит соединение двух экземпляров между собой:
<img width="634" alt="weakReference01_2x" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/a1dbdd77-220f-4132-86c7-191972f9c70b">
Экземпляр Person все еще имеет сильную ссылку на экземпляр Apartment, но Apartment имеет слабую (weak) ссылку на экземпляр Person. Это означает, что когда вы разрушаете сильную ссылку, которая содержится в переменной john, то больше сильных ссылок, указывающих на экземпляр Person, не остается:
```swift
john = nil
// Выведет "John Appleseed деинициализируется"
```
А так как больше сильных ссылок на экземпляр Person нет, то свойство tenant становится равным nil:
<img width="621" alt="weakReference02_2x" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/f05c6f8b-4a51-42b6-9f7b-8ad0a0737689">

Остается только одна сильная ссылка на экземпляр Apartment из переменной unit4A. Если вы разрушите эту сильную ссылку, то их общее количество станет равным нулю:
```swift
unit4A = nil
// выводит "Апартаменты 4A деинициализируется"
```

А так как больше сильных ссылок нет, то и экземпляр Apartment тоже освобождается:
<img width="618" alt="weakReference03_2x" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/ef69a70d-6bfb-4592-b9f3-6a426c6be7b6">

> Там, где используются сборщики "мусора", слабые указатели иногда используются для реализации простого механизма кеширования, потому что объекты без сильных связей сразу отпускаются, как только у памяти появляется необходимость избавится от "мусора". Однако со включенной ARC значения удаляются только тогда, когда уходит последняя сильная связь на них, делая слабые связи не подходящими для текущей задачи.

## Бесхозные опциональные (unowned) ссылки
Вы можете обозначить опциональные ссылки на класс как "unowned". С точки зрения модели ARC опциональная бесхозная ссылка и слабая ссылка могут быть использованы в одних и тех же контекстах. Разница лишь в том, что когда вы используете опциональную бесхозную ссылку, вы ответственны за то, чтобы она ссылалась на валидный объект или была бы установлена на nil.

Ниже приведен пример, который показывает курсы, которые в свою очередь может предложить департамент в школе:
```swift
class Department {
    var name: String
    var courses: [Course]
    init(name: String) {
        self.name = name
        self.courses = []
    }
}

class Course {
    var name: String
    unowned var department: Department
    unowned var nextCourse: Course?
    init(name: String, in department: Department) {
        self.name = name
        self.department = department
        self.nextCourse = nil
    }
}
```

Department держит сильную ссылку на каждый курс, который предлагает департамент. В модели владения ARC департамент владеет всеми курсами, что предлагает для прохождения. Сам тип Course имеет две бесхозные ссылки: одна на департамент, другая - на следующий курс, но сам курс не владеет ни одним из этих объектов. Каждый курс является частью департамента, так что свойство departament не является опциональным. Однако, некоторые курсы не имеют следующего курса, так что свойство nextCourse является опциональным.
Вот пример использования этих классов:

``` swift
let department = Department(name: "Horticulture")

let intro = Course(name: "Survey of Plants", in: department)
let intermediate = Course(name: "Growing Common Herbs", in: department)
let advanced = Course(name: "Caring for Tropical Plants", in: department)

intro.nextCourse = intermediate
intermediate.nextCourse = advanced
department.courses = [intro, intermediate, advanced]
```

Код выше создает департамент и его три курса. intro, intermediate курсы имеют последующий курс nextCourse, что поддерживает бесхозную опциональную ссылку на курс, который должен пройти студент после окончания текущего курса.

<img width="526" alt="Screenshot-2020-07-18-at-8 06 42-PM" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/ac368827-f308-4876-a5c9-fc0579c8ecb8">

Бесхозная опциональная ссылка не имеет сильной связи с экземпляром класса, который она удерживает, так что она не удерживает ARC от освобождения экземпляра класса. Она ведет себя точно так же как бесхозная ссылка в ARC за исключением того, что бесхозная опциональная ссылка может быть nil.
Как и в случае с неопциональными бесхозными ссылками, вы ответственны за то, чтобы nextCourse всегда ссылался на объект еще не освобожденный из памяти. В этом случае, например, когда вы удалите курс из department.courses, вам так же нужно удалить все ссылки, которые могут указывать на курс, который вы удалили.

> Лежащий в основе опционального значения тип - Optional, который является по своей сути просто перечислением в стандартной библиотеке Swift. Однако, опционалы являются исключением из правил, так как типы значений не могут быть маркированы как unowned.
Опционал, который является оберткой для класса не использует подсчет ссылок, так что вам не нужно поддерживать сильную ссылку на опционал.
