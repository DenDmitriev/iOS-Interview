# Property Wrappers 
Обертка свойства добавляет слой разделения между кодом, определяющий, как хранится или вычисляется свойство при чтении. Когда вы используете обертку, то вы пишете управляющий код один раз, а затем определяете обертку, которую можете переиспользовать для необходимых свойств.
SwiftUI предлагает 17 оберток свойств для наших приложений, каждое из которых обеспечивает различную функциональность. Знание того, какой из них использовать и когда имеет решающее значение для того, чтобы все было правильно.

### `@AppStorage` 
это обертка для всего приложения вокруг `UserDefaults`, она считывает и записывает значения из `UserDefaults`. Это означает, что он отлично подходит для хранения простых пар ключ/значение. Когда данные в UserDefaults изменяются, ваше представление перезагружается. Вы можете обновить значения в @AppStorage, присвоив значение вашей собственности. Прдестваление владеет данными.
Обратите внимание, что @AppStorage не предназначен для хранения полной модели данных для вашего приложения; он должен использоваться для небольших, простых данных.

Решая, стоит ли использовать @AppStorage
Вы должны использовать @AppStorage, когда:
- Вы храните простые пользовательские предпочтения.
- Вы хотите отслеживать простые данные, например, когда пользователь в последний раз запускал ваше приложение.
- Вам нужно сохранить какое-то очень простое состояние, которое должно сохранятся при перезапуске приложения.

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-appstorage-property-wrapper).

### `@SceneStorage` 
Обертка свойств @SceneStorage похожа на @AppStorage, за исключением того, что она сохраняет данные только локально для сцены, в которой в данный момент находится ваше представление. На iOS приложение обычно имеет одну сцену, но на Mac и iPad приложение может иметь несколько сцен. Когда сцена будет временно снесена и восстановлена позже, ваше хранилище сцены снова будет доступно. Если сцена уничтожена, все данные, связанные со сценой, также уничтожаются. Прдестваление владеет данными.
Решая, стоит ли использовать @SceneStorage
Вы должны использовать @SceneStorage, когда:
- Вы храните простое состояние, связанное с текущей сценой
- Данные, которые вы сохраняете, не являются конфиденциальными или критически важными
- Вы должны использовать хранилище сцен только для данных, связанных с состоянием, которые не являются важными для вашего приложения.

Вы используете @SceneStorage аналогично @AppStorage:


[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-scenestorage-property-wrapper).

### `@State` 
используется внутри объектов View и позволяет вашему представлению реагировать на любые изменения, внесенные в @State. Позволит нам изменять значения внутри структуры, что обычно не допускается, потому что структуры являются типами значений. Вы используете @State для свойств, которые принадлежат представлению, в котором оно содержится. Когда мы ставим @State перед свойством, мы эффективно перемещаем его хранилище из нашей структуры в общее хранилище, управляемое SwiftUI. Это означает, что SwiftUI может уничтожить и воссоздать нашу структуру, когда это необходимо (и это может произойти часто!), не теряя свойство, которое он хранил. `@State` 
Следует использовать с простыми типами структур и перечислений, такими как String, Int и массивы.

Решение о том, следует ли использовать @State:
- Сам вид создает (и владеет) экземпляром, который вы хотите обернуть.
- Вам нужно реагировать на изменения, которые происходят в обернутом свойстве.
- Вы обертываете тип значения (структуру или перечисление).
- iOS 17+: Вы упаковываете объект @Observable.

[Подробнее](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-state-property-wrapper).

### `@Binding` 
используется для свойств, которые передаются другим представлением. Вид, который получает привязку, может читать свойство, реагировать на изменения, внесенные внешними источниками (например, родительское представление), и имеет доступ к записи к свойству. Это означает, что обновление @Binding обновляет соответствующее свойство в представлении, которое предоставило @Binding. Относится к данным типа значения `value type`, принадлежащим другому представлению. Прдестваление не владеет данными.
Решение о том, следует ли использовать @Binding
Вы должны использовать @Binding, если:
- Вам нужен доступ для чтения и записи к свойству, которое принадлежит родительскому представлению.
- Свойство wrapped - это тип значения (структура или перечисление). (Вы также можете использовать @Binding для справочных типов (классов), но это не так распространено.)
- Вы не владеете завернутым свойством (оно предоставляется родительским представлением).

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-binding-property-wrapper).

### `@Environment` 
позволяет нам читать данные из системы, такие как цветовая схема, параметры доступности и коллекции черт, но вы можете добавить здесь свои собственные ключи, если хотите. 
Обертка свойств @Environment похожа на @EnvironmentObject с одним основным отличием. Он используется для чтения значений из среды представления. Если значение в среде изменится, ваше представление будет обновлено. Вы не можете использовать эту обертку свойств для установки или изменения свойства среды. Чтобы установить свойство @Environment для представления, вам необходимо использовать модификатор представления .environment(). 
Хороший способ думать о @Environment заключается в следующем сравнениее: @Environment для @EnvironmentObject как @State для @StateObject.
Прдестваление не владеет данными.

Решение о том, следует ли использовать @Environment
Вы должны использовать @Environment, если:
- Вы хотите ввести некоторое значение в среду SwiftUI с помощью ключа.
- Введенное свойство не должно вести себя как @EnvironmentObject.
- Свойство должно быть доступно для всех представлений, которые являются подпросмотрами представления, получившего модификатор .environment.

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-environment-property-wrapper).

### `@EnvironmentObject` 
читает общий объект, который мы поместили в среду. Иногда у вас есть объекты, которые нужны в разных местах в вашем приложении, и вы, возможно, не захотите передавать эти объекты в инициализатор каждого создаваемого вами вида. В этих случаях вы, возможно, захотите сделать зависимость доступной для всех детей представления, вашего приложения или сцены. Прдестваление не владеет данными.

@EnvironmentObject имеет ту же функциональность, что и @ObservedObject. Ваше представление будет повторно отрендерено при изменении одного из свойств @EnvironmentObject. Основное отличие заключается в том, что свойства @EnvironmentObject доступны в гораздо большем масштабе, чем @ObservedObject. В тех же случаях даже для всего вашего приложения.

Решение о том, следует ли использовать @EnvironmentObject
Вы должны использовать @EnvironmentObject, если:
- Обычно вы используете @ObservedObject, но вам придется передать ObservableObject через несколько инициализаторов представления, прежде чем он достигнет представления там, где это необходимо.

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-environmentobject-property-wrapper).


### `@FetchRequest` 
запускает запрос на выборку `Core Data` для конкретной сущности. Вы используете его для извлечения данных из Core Data. Прдестваление владеет данными.
Краткий пример того, как использовать эту обертку свойств, выглядит следующим образом:
```swift
struct ContentView: View {
    @FetchRequest(fetchRequest: MyModel.fetchRequest())
    var items: MyModel

    var body: some View {
        List(items) { item in
            Text(item.title)
        }
    }
}
```
Всякий раз, когда данные, загруженные @FetchRequest, обновляются, ваше представление также будет обновляться.
Решаю, стоит ли использовать @FetchRequest
Используйте @FetchRequest всякий раз, когда вы хотите получить данные из хранилища основных данных непосредственно в ваше представление.

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-fetchrequest-property-wrapper).

### `@FocusedBinding` 
предназначен для наблюдения с в возможностью изменения за значениями в ключевом окне, такими как текстовое поле, которое в данный момент выбрано. Прдестваление не владеет данными . [Больше информации](https://swiftwithmajid.com/2021/03/03/focusedvalue-and-focusedbinding-property-wrappers-in-swiftui/)

### `@FocusedValue` 
это более простая версия ### `@FocusedBinding`, которая только читает привязанное значение для вас. Прдестваление не владеет данными .

### `@GestureState` 
сохраняет значения, связанные с текущим жестом, например, как далеко вы его провели, отличается от `@State` тем что он будет сброшен до значения по умолчанию, когда жест остановится. Прдестваление владеет данными . [Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-gesturestate-property-wrapper).

### `@Namespace` 
создает пространство имен анимации, чтобы соединить соответствующие объекты общей анимацией, которые могут быть общими для других представлений. Прдестваление владеет данными.

### `@ObservedObject` 
используется для обертки экземпляров ObservableObject, которые не созданы или не принадлежат используемому представлению, служит чтобы представления могли следить за состоянием внешнего объекта и получать уведомления о том, что что-то важное изменилось. Он похож по поведению на `@StateObject`, за исключением того, что он не должен использоваться для создания объектов. Используйте @ObservableObject только с объектами, которые были созданы в другом месте, в противном случае SwiftUI может случайно уничтожить объект. Прдестваление не владеет данными.

Внутри хранилище SwiftUI не будет держать @ObservedObject, когда он отбрасывает и воссоздает представление, если это необходимо для нового рендеринга. Вместо этого SwiftUI знает, что родительское представление передаст ObservedObject (который может быть @StateObject), который используется в качестве значения для свойства, помеченного как @ObservedObject.

Решение о том, следует ли использовать @ObservedObject
Вы должны использовать @ObservedObject, если:
- Вы хотите реагировать на изменения или обновления в ObservedObject.
- Вид не создает экземпляр самого ObservedObject. (Если это так, вам нужен @StateObject)

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-observedobject-property-wrapper).

### `@Published` 
Прикрепляется к свойствам внутри ObservableObject и сообщает SwiftUI, что он должен обновлять любые представления, которые используют это свойство при его изменении. Прдестваление владеет данными . [Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-published-property-wrapper).

### `@StateObject` 
используется для хранения новых экземпляров данных ссылочного типа (reference type), которые соответствуют протоколу ObservableObject. Предназначена для заполнения очень специфического пробела в управлении состоянием: когда вам нужно создать тип ссылки внутри одного из ваших представлений и убедиться, что он остается живым для использования в этом представлении и других, с которыми вы делитесь им в отличии от `@ObservedObject`. Например мы создаем где-нибудь свой объект с помощью @StateObject, а затем используем его в других представлениях с помощью @ObservedObject. Прдестваление владеет данными. 

@StateObject для любого данного представления инициализируется только один раз. SwiftUI хранит экземпляр, связанный с вашим @StateObject, и повторно использует его, когда представление, которому принадлежит @StateObject, снова инициализируется. Другими словами, свойство, помеченное как @StateObject, будет сохранять первоначально назначенный экземпляр ObservedObject до тех пор, пока требуется представление, даже когда структура воссоздана SwiftUI. Это то же самое поведение, которое вы видите в @State, за исключением того, что оно применяется к ObservableObject, а не к типу значения, как структура.

Решение о том, следует ли использовать @StateObject
Вы должны использовать @StateObject, если:
- Вы хотите реагировать на изменения или обновления в ObservableObject.
- Вид, в котором вы используете @StateObject, создает экземпляр самого ObservableObject.

[Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-stateobject-property-wrapper).


### `@ScaledMetric` 
считывает настройку динамического типа пользователя и масштабирует числа вверх или вниз на основе исходного значения, заключанного вами, например для изменения размера объектов ы зависимости от настроек пользователя. Прдестваление владеет данными . [Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-scaledmetric-property-wrapper).

### `@NSApplicationDelegateAdaptor` 
используется для создания и регистрации класса в качестве делегата приложения для приложения macOS. Он владеет его данными. [Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/how-to-add-an-appdelegate-to-a-swiftui-app).

### `@UIApplicationDelegateAdaptor` 
используется для создания и регистрации класса в качестве делегата приложения для приложения iOS. Он владеет своими данными. [Больше информации](https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-uiapplicationdelegateadaptor-property-wrapper).


## Хранение временных данных в представлении
Когда дело доходит до хранения данных в вашем приложении, самая простая обертка свойств - это @State. Он предназначен для хранения типов значений, которые используются локально вашим представлением, поэтому он отлично подходит для хранения целых чисел, булов и даже локальных экземпляров структур.

Для сравнения, @Binding используется для простых данных, которые вы хотите изменить, но не принадлежат вашему представлению. В качестве примера представьте, как работает встроенный тумблер: ему нужно переключаться между состояниями включения и выключения, но он не хочет сохранять это значение сам, поэтому вместо этого у него есть привязка к некоторому внешнему значению, которым мы владеем. Итак, у нашего представления есть свойство @State, а у Toggle — свойство @Binding.

Для более сложных целей — например, для работы с классами или совместного использования данных во многих местах — вам не следует использовать @State и @Binding. Вместо этого вам следует создать где-нибудь свой объект с помощью @StateObject, а затем использовать его в других представлениях с помощью @ObservedObject.

> Простое правило заключается в следующем: если вы видите **State** в имени обертки свойств, это означает, что представление владеет этими данным.

Таким образом, `@State` означает простые данные типа значения (value type), созданные и управляемые локально, но, возможно, общие в других местах с помощью @Binding, а @StateObject означает данные эталонного типа, созданные и управляемые локально, но, возможно, общие в другом месте с помощью чего-то вроде @ObservedObject.

> Если вы когда-нибудь увидите @ObservedObject `var something = SomeType()`, это почти наверняка должно быть @StateObject, чтобы SwiftUI знало, что представление должно владеть данными, а не просто ссылаться на них в другом месте. Использование @ObservedObject здесь иногда может привести к сбою вашего приложения, потому что объект преждевременно уничтожен.

Если вы обнаружите, что передаете одни и те же данные от просмотра к просмотру, вы найдете полезную обертку свойств `@EnvironmentObject`. Это позволяет читать объект ссылочного типа из общей среды, а не передавать его явно.

Как и @ObservableObject, @EnvironmentObject не следует использовать для создания вашего объекта изначально. Вместо этого создайте его в другом представлении и используйте модификатор `environmentObject(myViewModel)` для введения его в среду. Хотя среда автоматически сохранит право собственности на ваш объект, вы также можете использовать @StateObject для хранения его там, где он был первоначально создан. Однако это не обязательно: поместить объект в окружающую среду достаточно, чтобы сохранить его жизнь без дальнейшего владения.

Окончательной оберткой свойств на основе состояния является @Published, которая используется внутри ваших ссылок-типов (reference type) для аннотации свойств. Любое свойство, отмеченное @Published, заставит его родительский класс объявить о том, что произошло изменение, что, в свою очередь, заставит любое представление, наблюдающее за этим объектом, внести любые необходимые ему изменения.

Например моздадим приложение список продуктов где реализуем обвертки:
```swift
struct ContentView: View {
    var body: some View {
        ShoppingList() // Представление которое будет показывать список покупок
    }
}
```

```swift
struct ShoppingList: View {
    
    @StateObject var shoppingNote = ShoppingNote() // 1: Класс который будет хранить все продукты
    @State var showAddProduct = false
    
    var body: some View {
        NavigationStack {
            VStack {
                if !shoppingNote.products.isEmpty {
                    List($shoppingNote.products) { product in
                        ProductItem(product: product) // 2: Представление которое оторажает объект
                    }
                } else {
                    Text("Add products")
                        .foregroundStyle(.secondary)
                }
            }
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        showAddProduct.toggle()
                    } label: {
                        Image(systemName: "plus")
                    }
                }
            }
            .sheet(isPresented: $showAddProduct) {
                AddProductView(shoppingNote: shoppingNote) // 3: Представление спомощью которого можно будет добавить продукты
                    .presentationDetents([.medium])
            }
        }
    }
}
```
```swift
class ShoppingNote: ObservableObject {
    @Published var products = [Product]() // 5: Массив с нашим списком продуктов за изменениями которыъ мы наблюдаем
}
```
```swift
struct AddProductView: View {
    @State var name: String = ""
    @State var emoji: String = ""
    @ObservedObject var shoppingNote: ShoppingNote // 4: Тот же объект хранения покупок из основного представления
    @Environment(\.dismiss) var dismiss
    private let emojiProduct = [...]
    
    var body: some View {
        VStack {
            HStack {
                TextField("🛒", text: $emoji)
                    .frame(width: 40)
                TextField("Product", text: $name)
                    .textFieldStyle(.roundedBorder)
            }
            .frame(height: 40)
            
            ScrollView {
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 20))]) {
                    ForEach(emojiProduct, id: \.self) { emoji in
                        Text(emoji)
                            .onTapGesture {
                                self.emoji = emoji
                            }
                    }
                }
            }
            
            Button("Add to list") {
                shoppingNote.products.append(Product(name: name, emoji: emoji))
                dismiss()
            }
            .buttonStyle(.borderedProminent)
            .disabled(!isProduct)
        }
        .padding()
    }
    
    var isProduct: Bool {
        !name.isEmpty && !emoji.isEmpty
    }
}
```

1: Так как мы хотим создать хранимый class объект c данными покупок то используем в исходном представлении обвертку @StateObject для ShoppingNote.

2: Мы передаем экземпляр Product в виде обвертки @Binding так как нам нужна привзяка с исходному объекту и мы хотим его менять в представлении.

3: AddProductView принимает в инициализатор уже созданный экземпляр shoppingNote объекта типа ShoppingNote.

4: Объект ShoppingNote в представлении AddProductView уже в обвертке @ObservedObject так как мы его создали ранее в представлении ShoppingList в обвертке @StateObject и он не уничтожится.

5: Массив покупок в обвертке @Published сможет объявить о том, что произошло изменение и заставитродительский класс обновить представление.

<img src='https://github.com/DenDmitriev/iOS-Interview/assets/65191747/b9a2c1e1-98e8-4001-bef0-87ffa9582a5c' width='250'>
<img src='https://github.com/DenDmitriev/iOS-Interview/assets/65191747/8d4afd5f-5396-4bb8-8fe0-3287375118ea' width='250'>

## Хранирание долгосрочных данных
SwiftUI имеет три обертки свойств, предназначенные для хранения и/или извлечения данных.

Первый - @AppStorage, который является оберткой для UserDefaults. Каждый раз, когда вы читаете или пишете значение из хранилища приложений, вы на самом деле читаете или пишете из UserDefaults.

Второй - @SceneStorage, который является оберткой вокруг API восстановления состояния Apple. Восстановление состояния - это то, что позволяет закрывать и перезагружать приложение, и возвращаться в то же состояние, которое оставил пользователь - это делает вид, что наши приложения всегда работали, даже если они были молча завершены.

> @AppStorage and @SceneStorage небезопасны и не должны использоваться для хранения конфиденциальных данных..

Хотя @AppStorage и @SceneStorage звучат одинаково, это не так: @AppStorage хранит одно значение для всего вашего приложения, тогда как @SceneStorage автоматически сохраняет несколько значений для одних и тех же данных в тех случаях, когда пользователь открывает окно вашего приложения несколько раз – например в iPadOS и MacOS.

Таким образом, вы можете использовать @AppStorage для хранения глобальных значений, таких как «Какой наивысший балл у пользователя?», и вы можете использовать @SceneStorage для хранения «какую страницу пользователь читает прямо сейчас?»

Третья обертка свойств данных - @FetchRequest, которая используется для извлечения информации из Core Data. Это будет автоматически использовать любой контекст управляемого объекта в среде и обновлять себя при изменении базовых данных.

## Чтение данных среды
SwiftUI имеет две обертки свойств для чтения среды пользователя: @Environment и @ScaledMetric.

@Environment используется для чтения широкого спектра данных, например, какой сбор признаков в настоящее время активен, используют ли они экран 2x или 3x, в каком часовом поясе они находятся и многое другое. Он также имеет несколько специальных действий приложения, таких как экспорт файлов и открытие URL-адреса в веб-браузере, зарегистрированном в системе.

@ScaledMetric намного проще и позволяет нам адаптировать размер нашего пользовательского интерфейса на основе настроек динамического типа пользователя. Например, коробка размером 100x100 может выглядеть отлично, используя размер системы по умолчанию, но с @ScaledMetric она автоматически станет 200x200, когда включена большая настройка динамического типа.

## Ссылки на представления
SwiftUI предоставляет оболочку свойства @Namespace, которая создает новое пространство имен для анимации. Пространства имен анимации позволяют сказать «анимировать представления с идентификатором 5», и все представления в этом пространстве имен с идентификатором 5 будут анимированы.

Вы можете совместно использовать пространства имен между представлениями, используя тип свойства Namespace.ID и вводя значение @Namespace из любого представления, создавшего его. Это позволяет создавать анимацию с эффектом согласованной геометрии в разных представлениях, а не хранить все данные в текущем представлении.

## Делегаты приложения
Если вам когда-либо понадобится доступ к старым методам и уведомлениям UIApplicationDelegate и NSApplicationDelegate, вам следует использовать оболочки свойств @UIApplicationDelegateAdaptor и @NSApplicationDelegateAdaptor соответственно.

Вы предоставляете их с классом вашего делегата приложения, и они позаботятся о том, чтобы экземпляр был создан и отправлены все соответствующие уведомления.

## Источники данных
Выше написано, какие обвертки свойств владеют своими данными. Обертки, которые владеют своими данными, являются источниками истины, потому что они создают значение и управляют им, а обертки, которые не владеют своими данными, не являются источниками истины, потому что они получают значение откуда-то еще.

| источники данных | передатчики данных |
| - | - |
| @AppStorage | @Binding |
| @FetchRequest | @Environment |
| @GestureState | @EnvironmentObject |
| @Namespace | @FocusedBinding |
| @NSApplicationDelegateAdaptor | @FocusedValue |
| @Published | @ObservedObject |
| @ScaledMetric | |
| @SceneStorage | |
| @State | |
| @StateObject | |
| @UIApplicationDelegateAdaptor | |

| Данные | Типы значений (value type) | Ссылочные типы (reference type) |
| - | - | - |
| Создание и хранение | @State | @StateObject |
| Передача | @Binding | @ObservedObject, @EnvironmentObject |


# Создание обертки
Для того, чтобы определить обертку, вы исользуете контруктор @propertyWrapper перед созданием структуры, перечисления или класса, который определяет свойство wrappedValue. В коде ниже структура TwelveOrLess, которая проверяет, что значение, которое она "оборачивает" всегда хранит значение равное или меньше 12. Если вы попробуете хранить большее значение, чем 12, то в итоге храниться будет именно 12.
```swift
@propertyWrapper
struct TwelveOrLess {
    private var number = 0
    var wrappedValue: Int {
        get { return number }
        set { number = min(newValue, 12) }
    }
}
```
Сеттер проверяет, что новые значения меньше 12, а геттер возвращает хранящееся значение.

Вы применяете обертку для свойства написав имя обертки перед свойством в виде атрибута. Вот пример структуры, которая хранит прямоугольник, который имеет обертку свойства TwelveOrLess для контроля того, что размеры этого прямоугольника будут равны или меньше 12:
```swift
struct SmallRectangle {
    @TwelveOrLess var height: Int
    @TwelveOrLess var width: Int
}

var rectangle = SmallRectangle()
print(rectangle.height)
// Выведет "0"

rectangle.height = 10
print(rectangle.height)
// Выведет "10"

rectangle.height = 24
print(rectangle.height)
// Выведет "12"
```
Свойства height и width получают свои начальные значения из определения обертки TwelveOrLess, которая устанавливаемо TwelveOrLess.number равным 0. Сеттер TwelveOrLess определяет 10 как подходящее значение, таким образом, хранит его в rectangle.height. Однако, число 24 больше чем позволяет хранить TwelveOrLess, так что попытка хранения значение 24 приводит к установке максимально допустимого значения rectangle.height равным 12.

Когда вы применяете обертку к свойству, то компилятор синтезирует код, который предоставляет хранилище для обертки, а так же код, который предоставляет доступ к свойству через эту обертку.

## Установка исходных значений для оберток свойств
Код в примерах выше устанавливал исходное значение для обернутого свойства предоставляя значение number в определение TwelveOrLess. Код, который использует эту обертку, не может предоставить другое исходное значение для свойства, которое обернуто в TwelveOrLess, например, определение SmallRectangle не может дать исходные значения для height и width. Для поддержки установки начального значения или другой настройки обертка свойств должна добавить инициализатор. Вот расширенная версия TwelveOrLess под названием SmallNumber, которая определяет инициализаторы, которые устанавливают обернутое и максимальное значение:
```swift
@propertyWrapper
struct SmallNumber {
    private var maximum: Int
    private var number: Int

    var wrappedValue: Int {
        get { return number }
        set { number = min(newValue, maximum) }
    }

    init() {
        maximum = 12
        number = 0
    }
    init(wrappedValue: Int) {
        maximum = 12
        number = min(wrappedValue, maximum)
    }
    init(wrappedValue: Int, maximum: Int) {
        self.maximum = maximum
        number = min(wrappedValue, maximum)
    }
}
```
Определение SmallNumber включает три инициализатора:
1.  `init()`. Код внутри этого инициализатора устанавливает начальное значение в обертке и начальное максимальное значение, используя значения по умолчанию, равные 0 и 12. 
2.  `init(wrappedValue : )`. Инициализатор использует указанное здесь значение в обертке и максимальное значение по умолчанию, равное 12.
3.  `init(wrappedValue: maximum: )`. Свойство создается путем вызова SmallNumber(wrappedValue: 2, maximum: 5), а экземпляр, который обертывает значение, создается путем вызова SmallNumber(wrappedValue: 3, maximum: 4).
4.  Смешанный. Swift обрабатывает присвоение как аргумент wrappedValue и использует инициализатор, который принимает включенные вами аргументы.
 Например:
```swift
struct SomeRectangle {
    @SmallNumber var height: Int //  1. init()
    @SmallNumber var width: Int = 1 // 2. init(wrappedValue : )
    @SmallNumber(wrappedValue: 2, maximum: 4) var cornerRadius: Int // 3. init(wrappedValue: maximum : )
    @SmallNumber(maximum: 9) var width: Int = 2 // 4. init(wrappedValue: 2, maximum: 9).
}
```

## Проецирование значения из обертки свойства $
В дополнение к обернутому значению обертка свойства может предоставлять дополнительные функциональные возможности, определяя проецируемое значение. Имя проецируемого значения такое же, как и значение в обертке, за исключением того, что оно начинается со знака доллара ($).

В приведенном выше примере SmallNumber, если вы попытаетесь установить для свойства слишком большое число, обертка свойства скорректирует это число перед его сохранением. Приведенный ниже код добавляет свойство projectedValue в структуру SmallNumber, чтобы отслеживать, скорректировала ли обертка свойства новое значение свойства перед сохранением этого нового значения.

```swift
@propertyWrapper
struct SmallNumber {
    private var number: Int
    private(set) var projectedValue: Bool

    var wrappedValue: Int {
        get { return number }
        set {
            if newValue > 12 {
                number = 12
                projectedValue = true
            } else {
                number = newValue
                projectedValue = false
            }
        }
    }

    init() {
        self.number = 0
        self.projectedValue = false
    }
}

struct SomeStructure {
    @SmallNumber var someNumber: Int
}

var someStructure = SomeStructure()

someStructure.someNumber = 4
print(someStructure.$someNumber)
// Выведет "false"

someStructure.someNumber = 55
print(someStructure.$someNumber)
// Выведет "true"
```
Написание someStructure.$someNumber получает доступ к проецируемому значению обертки. После сохранения небольшого числа, например четырех, значение someStructure.$someNumber становится false. Однако проецируемое значение равно true после попытки сохранить слишком большое число, например 55.

Обертка свойства может возвращать значение любого типа в качестве своего проецируемого значения. В этом примере обертка свойства предоставляет только одну часть информации - было ли число скорректировано - поэтому она предоставляет это логическое значение в качестве своего проецируемого значения. 

# Источники
- [All SwiftUI property wrappers explained and compared](https://www.hackingwithswift.com/quick-start/swiftui/all-swiftui-property-wrappers-explained-and-compared)
- [SwiftUI Property Wrappers](https://swiftuipropertywrappers.com)
- [Обертки свойств в Swift с примерами кода](https://habr.com/ru/companies/otus/articles/558486/)
- [Свойства](https://swiftbook.ru/content/languageguide/properties/)
