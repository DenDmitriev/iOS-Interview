# Потокобезопасность

## Потокобезопасность в CoreData
При работе с Core Data важно всегда помнить, что Core Data не является поточно-ориентированным. Базовые данные ожидают запуска в одном потоке. Это не означает, что каждая операция Core Data должна выполняться в главном потоке, что верно для UIKit, но это означает, что вам нужно помнить, какие операции выполняются с какими потоками. Это также означает, что вам нужно быть осторожным, как изменения из одного потока распространяются на другие потоки.

Работа с базовыми данными в нескольких потоках на самом деле очень проста с теоретической точки зрения. `NSManagedObject`, `NSManagedObjectContext` и `NSPersistentStoreCoordinator` не являются мультипоточными. Доступ к экземплярам этих классов возможен только из потока, в котором они были созданы. Как вы можете себе представить, это становится немного сложнее на практике.

### `NSManagedObject`
Мы уже знаем, что `NSManagedObject` не является потокобезопасным, но как получить доступ к записи из разных потоков? Экземпляр `NSManagedObject` имеет свойство `objectID` которое возвращает экземпляр класса `NSManagedObjectID`. Класс `NSManagedObjectID` является потокобезопасным, и экземпляр этого класса содержит всю информацию, которая необходима контексту управляемого объекта для извлечения соответствующего управляемого объекта.
```swift
// Object ID Managed Object
let objectID = managedObject.objectID
```
В следующем фрагменте кода мы запрашиваем контекст управляемого объекта для управляемого объекта, который соответствует `objectID`. `objectWithID(_:)` и `existingObjectWithID(_:)` возвращают локальную версию – локальную для текущего потока – соответствующего управляемого объекта.
```swift
// Fetch Managed Object
let managedObject = managedObjectContext.objectWithID(objectID)
 
// OR
 
do {
    let managedObject = try managedObjectContext.existingObjectWithID(objectID)
} catch {
    let fetchError = error as NSError
    print(“\(fetchError), \(fetchError.userInfo)”)
}
```
> Основное правило, которое нужно запомнить, – не передавать экземпляр NSManagedObject из одного потока в другой. Вместо этого передайте `objectID` управляемого объекта и запросите контекст управляемого объекта потока для локальной версии записи.

### `NSManagedObjectContext`
Поскольку класс `NSManagedObjectContext` не является потокобезопасным, мы могли бы создать контекст управляемого объекта для каждого потока, взаимодействующего с базовыми данными. Эта стратегия часто упоминается как ограничение потока.

Распространенным подходом является сохранение контекста управляемого объекта в словаре потока, словаре для хранения данных, специфичных для потока. Посмотрите на следующий пример, чтобы увидеть, как это работает на практике.
```swift
// Add Object to Thread Dictionary
let currentThread = NSThread.currentThread()
currentThread.threadDictionary.setObject(managedObjectContext, forKey: “managedObjectContext”)
```
Не так давно Apple рекомендовала такой подход. Даже при том, что это работает хорошо, есть еще один и лучший вариант, который Apple рекомендует сегодня. Мы рассмотрим этот вариант через несколько минут.

Как насчет постоянного координатора магазина? Вам нужно создать отдельный постоянный координатор хранилища для каждого потока. Хотя это возможно и является одной из стратегий, которые Apple рекомендовала, в этом нет необходимости.

Класс `NSPersistentStoreCoordinator` был разработан для поддержки нескольких контекстов управляемых объектов, даже если эти контексты управляемых объектов создавались в разных потоках. Поскольку класс `NSManagedObjectContext` блокирует координатор постоянного хранилища при доступе к нему, несколько контекстов управляемого объекта могут использовать один и тот же координатор постоянного хранилища, даже если эти контексты управляемого объекта живут в разных потоках. Это делает многопоточную настройку Core Data намного более управляемой и менее сложной.

### Стратегии параллелизма
Итак, мы узнали, что вам нужно несколько контекстов управляемых объектов, если вы выполняете операции Core Data в нескольких потоках. Однако предостережение заключается в том, что контексты управляемого объекта не знают о существовании друг друга. Изменения, вносимые в управляемый объект в одном контексте управляемого объекта, не распространяются автоматически в другие контексты управляемого объекта. Как мы решаем эту проблему?

Apple рекомендует использовать две популярные стратегии: 
1. Уведомления
2. контексты управляемых объектов «родитель-потомок». 

Давайте посмотрим на каждую стратегию и выясним их плюсы и минусы.

Сценарий, который мы возьмем в качестве примера, это подкласс `NSOperation` который выполняет работу в фоновом режиме и получает доступ к базовым данным в фоновом потоке операции. Этот пример покажет вам различия и преимущества каждой стратегии.

#### Стратегия Уведомления
Контекст управляемого объекта `NSFetchedResultsController` имеет три типа уведомлений:
- `NSManagedObjectContextObjectsDidChangeNotification`: это уведомление публикуется, когда один из управляемых объектов контекста управляемого объекта изменился.
- `NSManagedObjectContextWillSaveNotification`: это уведомление публикуется до того, как контекст управляемого объекта выполняет операцию сохранения.
- `NSManagedObjectContextDidSaveNotification`: это уведомление публикуется после того, как контекст управляемого объекта выполняет операцию сохранения.

Когда контекст управляемого объекта сохраняет свои изменения в постоянном хранилище, через координатор постоянного хранилища, другие контексты управляемого объекта могут захотеть узнать об этих изменениях. Это очень легко сделать, и еще проще включить или объединить изменения в другой контекст управляемого объекта. Давайте поговорим о коде.

Мы создаем не параллельную операцию, которая выполняет некоторую работу в фоновом режиме и требует доступа к базовым данным. Вот как может выглядеть реализация подкласса `NSOperation`.
