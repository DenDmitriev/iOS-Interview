# Aрхитектура
Архитектура программного обеспечения — совокупность важнейших принципов в организации программного кода. Можно сформулировать понятнее так.
Это шаблоны (принципы или паттерны) организации кода во всей программе или ее значительной части. Они определяют структуру программы в целом.

Архитектура включает:
- выбор структурных элементов и их интерфейсов, с помощью которых составлена система;
- стратегию, которая определяет всю организацию элементов, их интерфейсов, взаимодействие и соединение;
- масштабирование элементов структуры.

Общепринятого определения «архитектуры программного обеспечения» не существует.

## Абстракции:
### Модель
Под Моделью, обычно понимается часть содержащая в себе функциональную бизнес-логику приложения. Модель должна быть полностью независима от остальных частей продукта. Модельный слой ничего не должен знать об элементах дизайна, и каким образом он будет отображаться. Достигается результат, позволяющий менять представление данных, то как они отображаются, не трогая саму Модель.

Модель обладает следующими признаками:
- Модель — это бизнес-логика приложения;
- Модель обладает знаниями о себе самой и не знает о контроллерах и представлениях;
- Для некоторых проектов модель — это просто слой данных (DAO, база данных, XML-файл);
- Для других проектов модель — это менеджер базы данных, набор объектов или просто логика приложения;

### Представление (View)
В обязанности Представления входит отображение данных полученных от Модели. Однако, представление не может напрямую влиять на модель. Можно говорить, что представление обладает доступом «только на чтение» к данным.

Представление обладает следующими признаками:
- В представлении реализуется отображение данных, которые получаются от модели любым способом;
- В некоторых случаях, представление может иметь код, который реализует некоторую бизнес-логику.

# Aрхитектурные паттерны
Мы рассмотрим четыре наиболее важных для iOS-разработчика архитектурных паттерна:
- ​[MVC](#MVC)
- ​[MVP](#MVP)
- ​[MVVM](#MVVM)
- [VIPER](#VIPER)
- [VIP](#VIP)
- [Redux](#Redux)

## MVC
MVC — аббревиатура от *​Model — View — Controller*.​ Это архитектурный паттерн, который предписывает все верхнеуровневые компоненты системы разделять на три группы: 
1. слой **Model**, которая хранит внутренние данные о системе, предоставляет к ним доступ и содержит бизнес-логику приложения​,
2. слой **​View** (отображения), занимается только пользовательским интерфейсом. Она отображает то, что ей скажут, причем знает, как именно это нужно отобразить (верстка, анимации, шрифты и т. д.).​
3. слой **Controller**, который выступает в роли медиатора между View и Model:
  - имеет доступ к модели и узнает, когда она обновляется;
  - сам может обновить модель, перезаписать данные. Оповещение об изменении данных модели может быть реализовано через паттерн Observer;
  - указывает View, какие данные нужно отобразить (и иногда — как их нужно отобразить);
  - пользователь взаимодействует только с View через интерфейс. Controller обрабатывает это взаимодействие и решает, что из перечисленного выше нужно сделать. 

Взглянем на все ответственности, которые обычно несет Controller:
1. Конфигурировать UI;
2. Обновлять UI;
3. Ловить user interaction;
4. Обрабатывать user interaction;
5. Реализовывать бизнес-логику;
6. Обеспечивать навигацию между экранами.

Схема паттерна:

![Model - View - Controller](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/abc0dd8d-3628-49c4-9d66-88fa6276cd0b)

MVC в iOS:

<img width="731" alt="MVC в iOS" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/8447f319-5d98-4dda-aeb1-3bc394532b21">

#### Проблемы MVС

<img width="640" alt="Снимок экрана 2024-03-22 в 16 58 46" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/c0e8d829-6469-4ac0-9376-764fd63c28cd">

1. Massive View Controller. Слишком большие вью-контроллеры, которые берут на себя гигантское количество ответственностей.
2. Как известно, ​UIViewController контролирует жизненный цикл своего отображения (​viewDidLoad,​ ​viewDidAppear и т. д.). У контроллера всегда есть ​view,​ и она неотделима от контроллера. На практике получается очень сложно отделить слои View и Controller друг от друга так, чтобы они работали абсолютно независимо. Unit-тестирование и переиспользование компонентов такой системы оказывается затруднено.

## MVP
MVP — аббревиатура от *​Model — View — Presenter*.​ Это архитектурный паттерн, который предписывает все верхнеуровневые компоненты системы разделять на три группы: 
1. слой **Model**, которая хранит данные для отображения и работы​,
2. слой **​View** (отображения), занимается только пользовательским интерфейсом. Он отображает то, что ей скажут, причем знает, как именно это нужно отобразить (верстка, анимации, шрифты и т. д.), дополнительно берет на себя конфигурирование и обновление UI и ловит пользовательское взаимодействие.
3. слой **Presenter**, который выступает в роли Посредник между моделью View и Model:
  - имеет доступ к модели и узнает, когда она обновляется;
  - сам может обновить модель, перезаписать данные. Оповещение об изменении данных модели может быть реализовано через паттерн Observer;
  - указывает View, какие данные нужно отобразить (и иногда — как их нужно отобразить);
  - пользователь взаимодействует только с View через интерфейс. Controller обрабатывает это взаимодействие и решает, что из перечисленного выше нужно сделать.
  - обеспечивать навигацию между экранами.

Взглянем на все ответственности, которые доплучил View:
1. Конфигурировать UI;
2. Обновлять UI;
3. Ловить user interaction.

Взглянем на все ответственности, которые теперь несет Presenter:
1. Обрабатывать user interaction;
2. Управлять отображением View
3. Реализовывать бизнес-логику;
4. Обеспечивать навигацию между экранами.

В этом паттерне ​UIViewController рассматривается как View

![f1bcbfd44fc367c0e07e00d957ac188a](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/74d55a71-9810-4ff3-a883-327ca0ae67d6)

MVP в iOS:
Presenter не является наследником ​UIViewController и вообще никак не зависит от ​UIKit.

<img width="640" alt="MVP в iOS" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/83975f52-7b92-493b-80a0-390c8832fb7d">


**Чем отличается MVC от MVP?**
MVP — это реализация всех обещаний MVC о полной разделенности слоя ​View и слоя ​Controller.​ Это именно та цель, которой добивается MVP, преобразуя стандартную концепцию MVC в iOS. Все плюсы архитектуры MVP следуют именно из этой разделенности компонентов:
1. Лучшая разделенность ответственностей и как следствие — читаемость кода. В Presenter нет кода, ответственного за layout, а в View (то есть ​UIViewController и ​UIView)​
нет кода, ответственного за бизнес-логику и навигацию.
2. Возможность unit-тестирования. Бизнес-логику Presenter’а можно протестировать отдельно от View, просто заменив ее mock-объектом.
3. Переиспользуемость компонентов. В теории для одного и того же ​Presenter можно создать совершенно разные View, ведь они независимы друг от друга. На практике такая задача может возникнуть, например, если экран приложения находится в A/B-тесте с двумя разными UI. Иногда нужно поддерживать несколько таргетов в одном проекте: каждый таргет имеет свой UI, но бизнес-логика у приложений одинаковая.

#### Проблемы MVP
1. Больше кода. Раньше у нас был один класс для всего — ​UIViewController (кстати, вспомните про анти-паттерн God object). Теперь это как минимум два класса — ​UIViewController и ​Presenter,​ причем между ними надо проставить зависимости, то есть этот единый модуль из разных слоев нужно еще собрать. И для этого применить один из подходов, который почти наверняка приведет к созданию еще большего количества классов.
2. Главное неудобство по сравнению с одним ​UIViewController заключается в том, что теперь необходимо руками писать взаимодействие между View и Presenter, прокидывая вызовы методов либо через делегат, либо с помощью замыканий.
3. Ответственность Presenter’а все еще достаточно широка. Это отлично, что он не завязан на View, но он все еще занимается и бизнес-логикой, и работой с core-слоями приложения, и зачастую навигацией. Так что Presenter все еще может оставаться большим и запутанным классом.


### MVVM
MVP — аббревиатура от *​Model — View - ViewModel*. Архитектурный паттерн, состоящий из трех слоев (аналогично MVC и MVP). Эти слои — Model,​ ​View и ​ViewModel.​ В этом паттерне ​UIViewController рассматривается как View, как и в паттерне MVP. Поэтому схема для нас, в принципе, знакома:

![Model - View - View Model](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/04554431-1694-4aab-909d-a7c68463315e)

**Чем отличается MVP от MVVM?**
Можно даже не заметить разницы с MVP (кроме того, что слой посредника называется не ​Presenter,​ а ViewModel)​, но есть одна существенная деталь, которая отделяет два этих паттерна. Между ​View и ViewModel​ есть взаимодействие в обе стороны через ​binding​ (связывание).

Что такое ​binding​? По сути, это использование паттерна проектирования ​Observer для того, чтобы View всегда знала об изменениях ​ViewModel.​ На практике это выглядит так: класс ​ViewModel содержит логику по обработке пользовательского ввода, обращается к модели, запрашивает данные — в общем, аналогично Presenter’у в MVP. 

Но также ​ViewModel содержит свойства, к которым имеет доступ View и на изменение которых View подписана. Например, когда приходят данные с сервера, ViewModel записывает их у себя, и View сразу же узнает об изменениях и о том, что ей надо отрисовать новые данные.

#### Проблемы MVVM
MVVM дает большое преимущество в том, что касается удобного обновления отображения при изменении данных. Но, как и у любого архитектурного паттерна, у MVVM есть недостатки.
1. MVVM наследует проблему ​MVP — слой-посредник все еще может быть очень большим, просто раньше этим слоем был ​Presenter​, а теперь ​ViewModel.​ О решении мы также говорили — надо лучше разделять ответственности между классами, предварительно продумывая этот вопрос.
2. В MVVM возникает новая проблема — из-за активного использования ​binding дебаг приложения затрудняется. Из-за множественных вызовов замыканий усложняется ​stack trace.​
3. Поскольку для реализации ​binding в реальных проектах обычно используется ​реактивное програмирование, то​ нужно знать и его.

## VIPER
VIPER — аббревиатура от: *View – Interactor – Presenter – Entity – Router*. Но реальность такова, что в модуль входят не только эти компоненты, а Entity вообще в понятие модуля может не входить, т.к. является самодостаточным классом, который может использоваться в любом модуле или сервисе. На сложных экранах модуль можно делить на подмодули, где у каждого будут свои презентеры и интеракаторы.

![View - Interactor - Presenter - Entity - Router](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/c6a25006-8880-46f9-a993-401b6bbc63e7)

View:
1. Конфигурировать UI;
2. Обновлять UI;
3. Ловить user interaction.

Interactor:
1. Реализовывать бизнес-логику.
Задача интерактора — освободить презентер от логики, которая не завязана на отображение. При этом презентер продолжает отдавать команды вью-контроллеру, получать от него оповещения о пользовательских действиях и реагировать на них.

Presenter:
1. Обрабатывать user interaction.
2. Управлять отображением View.

Router:
1. Обеспечивать навигацию между экранами

Entity (Model):
1. Нет логики в отличии от Model в Mvc, Mvp, Mvvc

Пример:
Рассмотрим пример, иллюстрирующий взаимодействие слоев VIPER-модуля. Пользователь нажал на кнопку. Это нажатие ловит View и через протокол ​ViewOutput с помощью вызова соответствующего метода передает слою ​Presenter ответственность по обработке этого нажатия. ​Presenter знает, что после нажатия кнопки надо запросить данные, а пока данные запрашиваются — показывать на интерфейсе индикатор загрузки. ​Presenter через ​ViewInput вызывает метод показа индикатора загрузки. Как он будет показываться — решает ​View,​ ​Presenter здесь просто отдал команду. Дальше Presenter обращается к I​nteractor за данными. I​nteractor знает, откуда взять эти данные, причем они могут лежать в базе данных или в сети — чтобы получить их, возможно, придется сделать еще много всего, и этим занимается интерактор. Также интерактор знает, что запрос этих данных нужно залогировать, и делает это. Когда данные получены, I​nteractor возвращает данные в ​Presenter,​а он через ​ViewInput ​приказыват слою ​View​ отобразить эти данные и убрать индикатор загрузки.

<img width="1860" alt="Viper" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/c9644aed-9716-431f-b730-401e0931700d">

В общем, концептуально ​VIPER не так сложен, он просто идет еще дальше MVP и предлагает разделять ответственности между классами совсем атомарно. Такой подход будет отлично работать, если нужна максимальная переиспользуемость и тестируемость в особенно сложных экранах приложения.

### Преимущества и недостатки VIPER
Плюсы:
1. Лучше разделение ​— значит, ​лучше переиспользуемость и тестируемость, легче поддерживать код, легче вносить атомарные изменения, не задевая все сразу. Это гигантский плюс, который может перекрыть все остальное.
2. Разделение ответственностей единообразное — так что просматривая незнакомый VIPER-модуль, мы уже знаем, чем конкретно занимается каждый из его классов-слоев.

Минусы:
1. Больше классов, в целом больше кода, в том числе шаблонного, а из-за этого растет время компиляции проекта.
2. Presenter все равно подвержен опасности разрастания до очень большого класса, так как он является центральным элементом в модуле. Следить за этим — ответственность разработчика, предписаний у самой архитектуры по этому поводу нет.
3. Все модули строятся от ​View,​ то есть являются UI-зависимыми (кстати, именно эту проблему решали Uber внедрением своей собственной архитектуры ​RIBs)​.

### VIP
VIP и VIPER имеют одни и те же основные компоненты, но поток данных отличается. Хотя VIP следует однонаправленному подходу, VIPER имеет двунаправленный поток, который начинается с ведующего.

В VIPER ведущий направляет данные между представлением и интерактивным. Взгляд и интерактивный не разговаривают друг с другом.

<img width="1000" alt="VIP vs VIPER" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/ba8aa833-de30-40f9-ab90-b59b3751c67f">


## Какую архитектуру использовать?
MVC проще, но у ​MVP и ​VIPER такие шикарные преимущества. А еще есть ​MVVM,​ который тоже часто используется. Так что вопрос выбора архитектуры всегда решается внутри команды разработчиков, работающих над конкретным продуктом. Вот общие советы:
1. Если проект маленький и не планирует разрастаться — лучше использовать ​MVC и не заморачиваться с архитектурами.
2. Если вы один работаете над проектом — в большинстве случаев ​MVC будет достаточно, но в зависимости от сложности UI-составляющей плюсы ​MVP и ​MVVM могут оказаться очень полезными.
3. Если проект большой или в перспективе станет таким — надо задуматься над использованием более разделенной архитектуры. Если при этом над проектом работает более 3–5 человек одновременно, проблемы ​MVC могут оказаться очень болезненными на определенном этапе.
4. MVVM стоит использовать, когда нужна жесткая привязка отображения к изменяющимся данным.
5. VIPER​— это хорошо, но в широком классе проектов он будет избыточным.
6. MVP​— золотая середина среди всех архитектур. Так что, выбирая, можно начать с нее.

## Redux
Redux - это библиотека JS для управления состоянием приложения и создания адаптивного пользовательского интерфейса приложения в зависимости от состояния. Он следует центральному принципу, что привязка данных должна протекать в одном направлении и должна храниться как единый источник истины. Архитектура Redux состоит из строительных блоков, которые могут быть реализованы в Swift с помощью протоколов наблюдения очень простым и понятным способом.

<img width="1000" alt="Redux" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/6083051e-a92c-4231-9f51-de35380e4cc1">

- State: в зависимости от вашего состояния вы отображаете свой пользовательский интерфейс или отвечаете в любой форме. Таким образом, в основном состояние относится к источнику истины.
- Action: действия — это полезные данные или просто объекты информации, которые извлекаются из приложения посредством любых событий, таких как события касания, ответы сетевых API и т.д.
- Reducer (Редуктор) — это функция, которая берет текущее состояние из хранилища и действие. Он объединяет действие и текущее состояние и возвращает новое состояние.
- Store: Магазин хранит состояние. Store получает действие и передает его редуктору, получает обновленное состояние и передает его подписчикам. Важно отметить, что в приложении будет только один магазин. Если вы хотите разделить логику обработки данных, вы будете использовать композицию редуктора, то есть использовать множество редукторов вместо множества хранилищ.
- View подписывается на изменения состояния из магазина.
- Middleware - Промежуточные действия для выполнения задачи дополнительных задач.

<img width="400" alt="Redux" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/6ec84cdd-a415-4533-a5f6-22d253841570">

<img width="400" alt="Middleware" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/c26284f4-a117-4d7c-ac3f-ffef9871c714">


## Источники:
- [ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ](https://refactoring.guru/ru/design-patterns)
