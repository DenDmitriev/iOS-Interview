# TypeEraser
При использовании Combine Framework вы столкнетесь с концепцией TypeEraser. На самом деле это не имеет ничего общего с Combine Framework. Это скорее особенность языка. Но TypeEraser по своим терминам кажется несколько странным, потому что он на самом деле не удаляет тип. На самом деле он скрывает тип за каким-то другим типом AnyPublisher.

## AnyPublisher
Бывают случаи, когда вы хотите, чтобы подписчики подписывались на получение событий от издателя, не имея возможности получить доступ к дополнительной информации об этом издателе.
Например давайте создадим PassthroughSubject, который обрабатывает Integer и никогда не отправит ошибку:
```swift
let publisher = PassthroughSubject<Int, Never>()
```
В некоторых случаях вы хотите скрыть сведения о типе издателя, которого вы использовали. Таким образом, вы не хотите, чтобы клиент или кто-то другой, кто использует издателя, знал, что вы используете PassthroughSubject через тематического издателя. Вы хотите сохранить это в тайне. Что ты можешь сделать для этого сейчас? Ответ - использовать `eraseToAnyPublisher()`.

### `eraseToAnyPublisher()`
Вызываем функцию, которая называется `eraseToAnyPublisher()`. Это ничего не стирает. Это просто поставит ваш PassthroughSubject позади другого издателя. Это называется AnyPublisher.
```swift
let publisher: AnyPublisher<Int, Never> = PassthroughSubject<Int, Never>().eraseToAnyPublisher()
```

Это лучше всего продемонстрировать на примере, поэтому добавьте этот новый на свою игровую площадку:
```swift
var subscriptions = Set<AnyCancellable>()

// Создайте PassthroughSubject
let subject = PassthroughSubject<Int, Never>()

// Создайте издателя c функцией стирания типа издателя.
let publisher = subject.eraseToAnyPublisher()

// Подпишитесь на издателя.
publisher
    .sink(receiveValue: { print($0) })
    .store(in: &subscriptions)

// Отправьте новое значение через проходной субъект.
subject.send(0)
```
Нажмите, удерживая клавишу Option, на publisher, и вы увидите, что он имеет тип AnyPublisher<Int, Never>.

<img width="630" alt="Снимок экрана 2024-02-29 в 09 29 35" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/4e85119a-c05c-407d-a3a8-588b1b6615e1">

Нажмите, удерживая клавишу Option, на subject, и вы увидите, что он имеет тип PassthroughSubject<Int, Never>.

<img width="593" alt="Снимок экрана 2024-02-29 в 09 38 54" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/481df4f5-15a4-4bf0-ba98-520e1231b70b">

`AnyPublisher` - это стираемая типовая структура, которая соответствует протоколу Publisher. Функция `eraseToAnyPublisher()` возвращает тип `AnyPublisher<Self.Output, Self.Failure>` что позволяет вам скрыть сведения об издателе, которые вы, возможно, не захотите раскрывать подписчикам, или последущим издателям.

Ты сейчас испытываешь небольшое дежавю? Если это так, то это потому, что вы видели еще один случай стирания типа раньше. AnyCancellable - это класс стираемого типа, который соответствует Cancelable, который позволяет абонентам отменить подписку, не имея возможности получить доступ к базовой подписке, чтобы сделать такие вещи, как запрос большего количества элементов.

Одним из примеров того, когда вы хотите использовать стирание типа для издателя, является то, что вы хотите использовать пару публичных и частных свойств, чтобы позволить владельцу этих свойств отправлять значения частному издателю и позволить внешним абонентам получать доступ только к публичному издателю для подписки, но не иметь возможности отправлять значения.

AnyPublisher не имеет оператора send(_:), поэтому новые значения не могут быть добавлены к этому издателю.

Оператор eraseToAnyPublisher() обертывает предоставленного издателя в экземпляре AnyPublisher, скрывая тот факт, что издатель на самом деле является PassthroughSubject. Это также необходимо, потому что вы не можете специализировать протокол Publisher, например, вы не можете определить тип как Publisher<UIImage, Never>.

Чтобы доказать, что издатель стирается и не может быть использован для отправки новых значений, добавьте этот код в пример.
```swift
publisher.send(1)
```

Вы получаете ошибку "Value of type 'AnyPublisher<Int, Never>' has no member 'send'".

### Побочные эффекты?
Если вы примените это, все функции, связанные с PassthroughSubject, исчезнут, потому что вы скрыли тип за AnyPublisher.
Потому что ваш код теперь не будет знать внутренние детали и название издателя, которого использует ваш код. Ваш код не будет точно знать, какого издателя вы использовали.

## Вывод
Вся идея ластика типов заключается в том, чтобы просто поместить ваш конкретный тип за каким-то другим типом (AnyPublisher).

## Источники:
- [Publishers & Subscribers](https://www.kodeco.com/books/combine-asynchronous-programming-with-swift/v2.0/chapters/2-publishers-subscribers)
- [Swift Combine: TypeEraser, things you might have never known of](https://paigeshin1991.medium.com/swift-combine-typeeraser-things-you-might-have-never-known-of-fd8102c26b87)

