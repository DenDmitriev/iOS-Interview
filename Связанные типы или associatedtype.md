# Связанные типы или associatedtype

Ниже приведен пример протокола Container, который объявляет связанный тип ItemType:
```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```
Этот протокол не указывает количество и способ хранения элементов в контейнере или какого типа они должны быть. Протокол только лишь указывает три “кусочка” функциональности, которые должны быть предоставлены контейнером, чтобы он считался Container. Соответствующий тип может предоставлять дополнительную функциональность, пока он удовлетворяет этим трем требованиям.

Для определения этих требований, протокол Container должен иметь способ ссылаться на тип элементов, которые он будет хранить, без указания типа элементов, которые может хранить конкретный контейнер. Протокол Container должен указать, что любое значение переданное в метод append(_:) должно иметь тот же тип, что и тип элементов контейнера, и что значение, возвращаемое сабскриптом контейнера, должно быть того же типа, что и элементы контейнера.

Чтобы добиться этого, протокол Container объявляет связанный тип `Item`, который записывается как `associatedtype Item`. Протокол не определяет для чего конкретно нужен алиас `Item`, потому что эта информация остается для любого соответствующего класса протоколу. Тем не менее, алиас `Item` предоставляет способ сослаться на тип элементов в Container и определить тип для использования метода append(_:) и сабскрипта, для того, чтобы гарантировать, что желаемое поведение любого Container имеет силу.

Ниже приведена версия неуниверсального типа IntStack, который адаптирован под протокол Container:

```swift
struct IntStack: Container {
    // исходная реализация IntStack
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
    // удовлетворение требований протокола Container
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Int {
        return items[i]
    }
}
```

Тип `IntStack` реализует все три требования протокола Container, и в каждом случае оборачивает часть существующей функциональности типа IntStack для удовлетворения этих требований.
Более того, IntStack указывает, что для этой реализации контейнера, подходящий тип `Item` будет `Int`. Определение `typealias Item = Int` преобразует абстрактный тип `Item` в конкретный тип `Int` для этой реализации протокола `Container`.
Благодаря выводу типов Swift, вам фактически не нужно указывать конкретный тип `Int` для `Item` как часть определения `IntStack`. Так как IntStack соответствует протоколу Container, Swift может вывести соответствующий тип для Item, просто посмотрев на тип параметра item метода append(_:) и на тип возвращаемого значения сабскрипта. И на самом деле, если удалить строку кода `typealias Item = Int`, все будет продолжать работать, потому что все еще ясно какой тип должен быть использован для `Item`.
