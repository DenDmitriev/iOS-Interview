# Виды диспетчеризации
- Статическая или прямая отправка (Static or direct dispatch)
- Табличная или динамическая отправка (Table or dynamic dispatch)
- Отправка сообщений (Message dispatch)


## Прямая отправка
Прямая отправка — это самый быстрый способ отправки метода. Это не только приводит к наименьшему количеству инструкций ассемблера, но и компилятор может выполнять всевозможные хитрости, такие как встраивание кода и многие другие вещи, которые выходят за рамки этой статьи. Это часто называют статической отправкой.
Однако прямая диспетчеризация также является наиболее ограничительной с точки зрения программирования и недостаточно динамичной для поддержки создания подклассов.
 - Структуры (Value type Data type)
 - `static` и `final` (Reference type with this keyword)


## Отправка таблицы или динамическая отправка (Table Dispatch or Dynamic dispatch)
Отправка таблиц — наиболее распространенная реализация динамического поведения в компилируемых языках. При отправке таблицы используется массив указателей функций для каждого метода в объявлении класса. В большинстве языков это называется «virtual table», но Swift использует термин «witness table» (таблица-свидетель). Каждый подкласс имеет собственную копию таблицы с разными указателями на функции для каждого метода, переопределенного классом.

```swift
class Parent {
    func method1() {}
    func method2() {}
}

class Child: Parent {
    override func method2() {}
    func method3() {}
}
```

![tableDispatch](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/d731e9dc-d474-419b-a2d4-a41a16f33402)

Этот код создаст массив для адреса функции. По мере того, как подклассы добавляют в класс новые методы, эти методы добавляются в конец этого массива. Затем эта таблица просматривается во время выполнения, чтобы определить метод для запуска.

Однако этот метод отправки по-прежнему медленный по сравнению с прямой отправкой. С точки зрения байт-кода, есть два дополнительных чтения и переход, которые вносят некоторые накладные расходы. Однако еще одна причина, по которой это считается медленным, заключается в том, что компилятор не может выполнять какие-либо оптимизации в зависимости от того, что происходит внутри метода.
Одним из недостатков этой реализации на основе массива является то, что:
- расширения не могут расширять таблицу диспетчеризации. Поскольку подклассы добавляют новые методы в конец таблицы диспетчеризации, не существует индекса, к которому расширение могло бы безопасно добавить указатель на функцию.

## Отправка сообщений (Message dispatch)
Хотя этот метод отправки сообщений является наиболее динамичным типом, он самый медленный из всех других типов отправки. В диспетчере таблиц таблица-свидетель генерируется во время компиляции, но при отправке сообщений невозможно решить, какой метод вызывать, поскольку он мог быть изменен или новые методы могли быть добавлены во время выполнения. Однако фреймворки Cocoa используют его внутри многих своих крупных игроков, таких как KVO, Core Data и других.
Кроме того, он позволяет изменять функциональность метода, что обычно означает, что, используя этот метод, мы можем изменить функциональность метода во время выполнения.

![messageDispatch](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/b313a132-860a-4284-8c47-4c2c40f28beb)

При отправке сообщения среда выполнения просматривает иерархию классов, чтобы определить, какой метод следует вызвать. На самом деле это не так уж и медленно, поскольку реализовано с использованием высокопроизводительного кэша.

> Компилятор всегда пытается обновить технику диспетчеризации до статической, если мы явно не пометили ее динамическим ключевым словом @objc.

```swift
class Parent {
    func method1() {}
    func method2() {}
}

class Child: Parent {
    func method3() {}
}

extension Child {
    override func method2() {} //Error: Non-@objc instance method 'method2()' declared in 'Parent' cannot be overridden from extension. Add '@objc' to make this declaration overridable
}
```
В коде мы видим ошибку, говорящую, что функцию нельзя переопределить в расширении. Это связано с тем, что method2() объявлен в расширении, что означает, что метод будет вызываться при отправке сообщения. При вызове method3() отправляется объекту ParentClass посредством диспетчеризации таблицы. Поскольку переопределение ClildClass было добавлено посредством отправки сообщений, таблица отправки ClildClass по-прежнему содержит реализацию ParentClass в таблице отправки, поэтому происходит путаница, и вы получаете ошибку. Чтобы это работало, мы можем либо переместить этот метод расширения в ClildClass, а не в расширение ClildClass.

## Отправка метода в зависимости от типа.

|   | Initial Declaration | Extension |
| ----------- | ----------- | ----------- |
| Value Type   | Static  | Static   |
| Protocol   | Table  | Static   |
| Class   | Table   | Static   |
| NSObject Subclass   | Table  | Message |

Здесь следует отметить несколько вещей: 
- Типы значений всегда используют прямую отправку. Легко и приятно!
- Расширения протоколов и классов используют прямую диспетчеризацию.
- Расширения NSObject используют отправку сообщений
- `NSObject` использует диспетчеризацию таблиц для методов внутри исходного объявления!
- Реализации методов по умолчанию в исходном объявлении протокола используют диспетчеризацию таблицы.

## Источники
- [Method Dispatch in Swift](https://medium.com/@pallavidipke07/method-dispatch-in-swift-b113a40a713a)
