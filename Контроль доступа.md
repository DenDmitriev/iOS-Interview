# Контроль доступа

Контроль доступа ограничивает доступ к частям вашего кода из кода других исходных файлов и модулей. Эта особенность позволяет вам прятать детали реализации вашего кода и указывать на предпочтительный интерфейс, через который можно получить доступ к вашему коду.

Swift предлагает пять различных уровней доступа для объектов вашего кода. Эти уровни доступа относительны исходному файлу, в котором определен объект, и так же они относительны модулю, которому принадлежит исходный файл:
1. Открытый доступ и публичный доступ (**open** access и **public** access). Этот уровень доступа позволяет использовать объекты внутри любого исходного файла из определяющего их модуля и так же в любом исходном файле из другого модуля, который импортирует определяющий модуль. Вы обычно используете открытый и публичный доступы, когда указываете общий интерфейс фреймворка. Отличия между этими двумя уровнями доступа будет описаны ниже.
2. Внутренний (**internal** access). Этот уровень доступа позволяет использовать объекты внутри любого исходного файла из их определяющего модуля, но не исходного файла не из этого модуля. Вы обычно указываете внутренний доступ , когда определяете внутреннюю структуру приложения или фреймворка.
3. Файл-частный (**file private**). Этот уровень доступа позволяет использовать объект в пределах его исходного файла. Используйте файл-частный уровень доступа для того, чтобы спрятать детали реализации определенной части функциональности, когда эти части функциональности будут использоваться внутри другого файла.
4. Частный (**private**). Этот уровень доступа позволяет использовать сущность только в пределах области ее реализации. Используйте частный доступ для того, чтобы спрятать детали реализации конкретной части функциональности, когда они используются только внутри области объявления.

## Открытый доступ Open
самый высокий уровень доступа (наименее строгий), и частный уровень доступа является самым низким уровнем доступа (самый строгий).
Открытый доступ применяется только к классам и членам класса и отличается от public доступа следующим:
 - Классы, с уровнем доступа public, могут наследоваться только в том модуле, в котором они определены.
 - Члены класса с уровнем доступа public или с более строгим уровнем доступа могут быть переопределены подклассами только в том модуле, в котором они определены.
 - Открытые классы могут наследоваться внутри модуля, в котором они определены и внутри модуля, который импортирует модуль, в котором они определены.
 - Открытые члены класса могут переопределяться подклассами внутри модуля, в котором они были определены или внутри модуля, который импортирует модуль, в котором они были определены.
 - Обозначая класс через маркер open, явно свидетельствует о том, что вы рассмотрели влияние этого класса на код других модулей, использующих его в качестве суперкласса.

## Дефолтный уровень доступа

Все сущности вашего кода (кроме двух исключений, о которых мы поговорим чуточку позже) имеют дефолтный уровень доступа - внутренний (**internal**), если вы явно не указываете другой уровень. В результате во многих случаях вам не нужно указывать явный уровень доступа в вашем коде.

## Уровень доступа для фреймворка

Когда вы разрабатываете фреймворк, обозначьте внешний интерфейс фреймворка как **open**, **public**, так чтобы его можно было посмотреть и получить к нему доступ из других модулей, так например, чтобы приложение могло импортировать его. Внешний интерфейс - интерфейс прикладного программирования (API) для фреймворка.

## Уровни доступа для модуля поэлементного тестирования (unit test target)

Когда вы пишете приложение с модулем поэлементного тестирования, то код вашего приложения должен быть доступным для модуля, чтобы он мог его проверить. По умолчанию только сущности с маркировкой public могут быть доступны для других модулей, однако этот модуль может получить доступ ко всем внутренним сущностям, если вы поставили входную маркировку объявления модуля продукта как @testable и компилируете со включенным режимом тестирования.

## Синтаксис контроля доступа

Определите уровень доступа для объекта, установив одно из ключевых слов (**private, fileprivate, internal, public, open**) перед вступительным словом сущности:
```swift
public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}
 
public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}
```
Если вы не укажете уровень доступа, то он будет **internal** по умолчанию, о чем было поведано в главе Уровни доступа. Это значит, что SomeInternalClass и someInternalConstant могут быть записаны без явного указания модификатора уровня доступа, и они все равно будут все еще иметь **internal** уровень доступа:
```swift
class SomeInternalClass {}              // неявно internal
let someInternalConstant = 0            // неявно internal
```
