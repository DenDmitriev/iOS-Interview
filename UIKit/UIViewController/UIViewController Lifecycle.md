# Жизненный цикл UIViewController
UIViewController - это класс, который содержит представление `view`. Вы добавляете свои представления именно в это корневое представление контроллера. Чтобы понять жизненный цикл, вам нужно знать, что:
> Представление `view` не создается с инициализацией контроллера `UIViewController`.

Контроллеру нужна причина для создания объекта представления `view`. Концепция жизненного цикла построена вокруг этой функции. Имейте в виду, что представление `view` контроллера создается не сразу, а по мере необходимости.

![hello](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/fe79b4db-efb5-429f-853e-48fafd96b0b5)

## Инициализация `UIViewController`
Рассмотрим UIViewController. Доступны два инициализатора:

```swift
override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
}
    
required init?(coder: NSCoder) {
    super.init(coder: coder)
}
```

Существует также инициализатор без параметров init(), но это обертка над первым инициализатором.

В этот момент контроллер инициализирует свойство и заполняет тело инициализатора. Представление `view` не загружено, розетки `outlets` не активны. Только имя файла сохраняется в инициализаторе с помощью nib, но сам файл не загружается.

## Загрузка представления `View`
Контроллер загружает представление `view`, но не сразу. У контроллера есть методы жизненного цикла, с помощью которых мы отслеживаем процесс загрузки `view` и добавляем логику.

1. Первый метод `loadView()` вызывается системой. Его не нужно вызывать вручную. Но вы можете переопределить его, чтобы переопределить корневое представление. 
Если вам нужно загрузить представление вручную (и вы уверены, что это необходимо). Флаг `isViewLoaded` показывает, загружено ли представление или нет.
```swift
    override func loadView() {
        // code
    }
```

2. Второй метод `viewDidLoad()` вызывается, когда представление `view` закончило загрузку.
```swift
    override func viewDidLoad() {
        super.viewDidLoad()

        // Do any additional setup after loading the view.
    }
```
Перед вызовом этого метода корневого представления не существует, а уже после этого контроллер готов к появлению на экране. В `viewDidLoad()` память для представления выделена, представление загружено и готово к настройке.

> Представление не может быть настроено в инициализаторе: если вы вызываете `myController.view` - он загрузится. Но контроллер сейчас не виден, и, возможно, он вообще никогда не появится. Вы потратите память и займете  главынй поток `main thread`.

Это не уничтожит приложение, но элементы интерфейса потребляют память - вы не хотите тратить их впустую, прежде чем они понадобятся. Делайте это по мере необходимости.

При создании свойств представления контроллера следующим образом:
```swift
class MyViewController: UIViewController {
    let redView = UIView()
}
```
cвойство инициализируется вместе с контроллером, что означает, что память для представления будет выделена немедленно. Правильно сделать это отложить это до требования, пометить свойство как ленивое `lazy`.

В методе `viewDidLoad()` размеры представления неверны - вы не можете привязатся к высоте и ширине. Но можно сделайте настройку, которая не зависит от размеров.

## Показ представления на экране
Настройка внешнего вида контроллера начинается с метода viewWillAppear:
```swift
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated) // Уведомляет контроллер представлений о том, что его представление вот-вот будет добавлено в иерархию представлений.
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated) // Уведомляет контроллер представлений о том, что его представление было добавлено в иерархию представлений.
    }
```
Появление контроллера в модальном окне или например переход в `UINavigationController` вызовет `viewWillAppear` перед анимацией и `viewDidAppear` после нее. Когда вызывается `viewWillAppear`, представление уже находится в иерархии.

Оба метода объединены. Нам не нужно делать здесь какие-либо настройки, но мы можем добавить несложное поведение. В методе `viewDidAppear()` можно запустить сетевой запрос или вращайте индикатор нагрузки. Оба метода могут вызваться несколько раз при переходах.

## Скрытие представления с экрана
Скрытие представления происходит при переходе на новое представление или закрытии представления.
Вызываются следующие методы:
```swift
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated) // Уведомляет контроллер представлений о том, что его представление вот-вот будет удалено из иерархии представлений.
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated) // Уведомляет контроллер представлений о том, что его представление было удалено из иерархии представлений.
    }
```
Они вызываются, когда представление удаляется из иерархии представлений. Если вы показываете другой контроллер над текущим представлением, то методы не вызываются.

Схема жизненного цикла UIViewController

![header-en](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/5f9299ad-d721-4c59-9dc6-3a8b3efe777d)


## Макет (Layout)
Методы layout привязаны к жизненному циклу представления `view`. Доступны три метода:
```swift
    // 1
    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews() // Вызывается для уведомления контроллера представления о том, что его представление собирается разметить свои подпредставления.
    }
  
    // 2
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews() // Вызывается для уведомления контроллера представления о том, что его представление только что разместило свои подпредставления.
    }
```
Первый метод вызывается перед `layoutSubviews()` корневого представления `view`, второй метод вызывается после. Во втором методе размеры верны, и представление размещено правильно - мы можете связать что-либо с размерами корневого представления.

Существует отдельный метод для изменения размера вида. Это также называется для поворота устройства:
```swift
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
    super.viewWillTransition(to: size, with: coordinator)
}
После него вызываются методы `viewWillLayoutSubviews()` и `viewDidLayoutSubviews()`.
```

## Переполнение памяти (Memory is out)
Если вы не очистите объекты, вызывавшие переполнение памяти, iOS принудительно завершит работу приложения. Этот метод является предупреждением, у вас есть шанс освободить немного памяти.
```swift
override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
```

## Полная схема цикла работы UIViewController

![6b17060117a2c525d6440495176a3ceb](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/6b998e40-2f2f-4d1b-ba43-5ded99406927)


## Источники
- [UIViewController Lifecycle](https://sparrowcode.io/en/tutorials/uiviewcontroller-lifecycle)
