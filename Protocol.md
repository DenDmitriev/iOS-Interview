# Protocol
Описание функциональности объектов в виде обобщенного интерфейса. Может использоваться в качестве типа свойства, в качестве типа результата функции.
Протокол фактически не предоставляет реализацию для любого из этих интерфейсов, он только описывает какие интерфейсы должны быть в объекте. Протокол может быть принят классом, структурой или перечислением для обеспечения фактической реализации этих требований интерфейса. 

```swift
protocol SomeProtocol {
    // определение протокола…
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }

    func someTypeMethod()
}

struct SomeStructure: SomeProtocol {
    // определение структуры…
}

class SomeClass: SomeSuperclass, SomeProtocol {
    // определение класса…
}
```

Может содержать associated types.

## associated types
При определении протокола бывает нужно определить связанные типы в качестве части определения протокола. Связанный тип дает плейсхолдер имени типу, который используется как часть протокола. Фактический тип, который будет использоваться связанным типом не указывается до тех пор, пока не будет принят протокол. Связанные типы указываются при помощи ключевого слова `associatedtype`.
```swift
protocol Container {
    associatedtype Item

    func append(_ item: Item)
}
```

## Использование:
- предоставляют функциональность и передаются классам-потребителям как зависимости
- использование как шаблон для типа для требования реализации декларированных методов и свойств всем наследникам

## Extensions 
Протоколы могут быть расширены для обеспечения метода и реализации свойства соответствующими типами. Это позволяет вам самостоятельно определить поведение по протоколам, а не по индивидуальному соответствию каждого типа или глобальной функции.
```swift
protocol RandomNumberGenerator {
    func random() -> Double
}

extension RandomNumberGenerator {
    func randomBool() -> Bool {
        return random() > 0.5
    }
}
```

Создавая расширение по протоколу, все соответствующие типы автоматически получают эту реализацию метода без каких-либо дополнительных изменений.

## Наследование протокола
Протокол может наследовать один или более других протоколов и может добавлять требования поверх тех требований протоколов, которые он наследует. 
```swift
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // определение протокола…
```

## Классовые протоколы
Вы можете ограничить протокол так, чтобы его могли принимать только классы (но не структуры или перечисления), добавив AnyObject протокол к списку реализации протоколов.

```swift
protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // определение протокола типа class-only
}
```
В примере выше SomeClassOnlyProtocol может быть принят только классом. Если вы попытаетесь принять протокол SomeClassOnlyProtocol структурой или перечислением, то получите ошибку компиляции.

## Композиция протоколов
Иногда бывает удобно требовать тип, который будет соответствовать сразу нескольким протоколам. Вы можете скомбинировать несколько протоколов в одно единственное требование при помощи композиции протоколов.
```swift
protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named & Aged) {
    print("С Днем Рождения, \(celebrator.name)! Тебе уже \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Сашка", age: 21)
wishHappyBirthday(to: birthdayPerson)
// Выведет "С Днем Рождения, Сашка! Тебе уже 21!"
```

## Опциональные требования протокола
Вы можете определить опциональные требования для протокола. Эти требования не обязательно должны быть реализованы для соответствия протоколу. Опциональные требования должны иметь префиксный модификатор @objc optional в качестве части определения протокола, и при этом наличие @objc позволяет коду Swift взаимодействовать с кодом Objective-C. Обратите внимание, что протоколы с маркировкой @objc могут приниматься только классами, но не структурами или перечислениями.

```swift
@objc protocol Nameable {
    @objc optional var name: Int { get set }
}

class Animal: Nameable {
    
}
```

## Добавление ограничений к расширениям протоколов
Когда вы определяете расширение протокола, вы можете указать ограничения для принимающих типов, которые они должны удовлетворить до того, как будут доступны методы и свойства расширения. Вы записываете эти ограничения сразу после имени протокола, при помощи оговорки where.

```swift
extension Collection where Element: Equatable {
    func allEqual() -> Bool {
        for element in self {
            if element != self.first {
                return false
            }
        }
        return true
    }
}
```
