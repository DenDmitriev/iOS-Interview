# Render Loop
Render loop — это цикл отрисовки в системе iOS.

![84435f7a41e14705b4790924773c9d0b](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/6a59829a-a886-4be3-be67-333b3855c8ff)

Жизненный цикл у него такой:
1. Получаем событие
2. Создаем render tree
3. Отправляем на Render Server
4. Меняем кадр

![df898b7a976ac9b0926987c08646acff](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/197d910d-d537-430b-abfb-3ce7b27f04c5)

Сначала происходит какое-то событие (Тач, колбэк с сети, действие с клавиатуры, таймеры). Допустим мы хотим изменить bounds нашей вьюхи, то Core Animation вызывает метод setNeedsLayout. Система понимает, что нужно вызвать апдейт лайут реквеста.

![a6a66988971f66984bda877870e2771c](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/95f98999-12a9-4591-81c7-a3411770d66f)


В основе всех обновлений слоев и анимаций лежит Core Animation. Этот фреймворк работает не только внутри самого приложения, но и между другими приложениями. Когда мы переключаемся из приложения в приложение.

Сама анимация происходит в другом этапе, за рамками нашего приложения. Этот этап называется render server.

На этапе же commit transaction происходит подготовка layer tree и его неявная транзакция для обновления.

Транзакции — это механизм, который Core Animation использует для обновления свойств. Любые свойства наших слоев не изменяются мгновенно, а вместо этого подготавливаются в транзакцию и ждут своего коммита

Когда мы хотим выполнить анимацию, то сначала проходим 4 этапа:
1. Layout — На этом этапе мы подготавливаем вьюхи, их свойства (frame, background color, border и другие). Как только лайаут расчитался, система вызывает метод setNeedsDisplay.
2. Display — обновляет CGContext. Это рисование может включать вызов функций drawRect, drawLayer каждых subviews
3. Prepare — На этом этапе Core Animation готовится отправить данные анимации на render server. Здесь происходит подготовка и декодинг картинок
4. Commit — Это заключительный этап, когда Core Animation упаковывает слои и свойства анимации и отправляет их через Interprocess communication (IPC) на render server для отображения.

Core Animation объединяет изменения в транзакцию, кодирует их и фиксирует на render server.
Окей, мы подготовили наш render tree и отдали их следующему этапу.

## Render Server
Теперь мы на рендер сервере — это отдельный процесс, который вызывает методы отрисовки для GPU с использованием бибилотек OpenGL или Metal. Он отвечает за рендер наших слоев в изображение

### Render Prepare
На этом этапе происходит пробег про layer tree и мы подготавливаем layer pipeline для выполнения его на GPU. Рекурсивно пробегаясь от родительского слоя к дочернему.

![aeb1e86141758e507df48c5fb904471d](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/6786dca5-5251-4f6f-bfdc-93272cff10c0)

### Render Execute
После layers pipeline передан на отрисовку. Где каждый слой будет собран в финальную текстуру. До этого момента все вычисления происходили в CPU, но дальше работа перешла в руки GPU.

![0b7264b06037e177a356c4eff95f342e](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/f045f21c-39e0-4610-b7d3-78842c5c377f)

Как только GPU выполняет отрисовку изображений, то это готово к отображению для следующего VSYNC. VSYNC — это дедлайн для каждой фазы нашего рендер лупа. Каждый VSYNC — меняет нам следующий кадр для достижения лучшей оптимизации каждый фрейм распараллеривается. Пока CPU читает кадр номер N, в это время GPU рендерит предыдущий кадр N-1

![00d03a58f78927d250d775b3974f9162](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/281347ed-4a58-456a-89db-e4c257ee1c84)


## Источники:
- [Оптимизация рендера в iOS: frame buffer, Render Server, FPS, CPU vs GPU](https://habr.com/ru/articles/647177/)
