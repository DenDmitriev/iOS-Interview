# Generics или Универсальные шаблоны

Generic код позволяет создавать многократно используемые функции и типы данных, которые могут работать с любым типом, отвечающем определенным ограничениям. Этот подход позволяет писать код, который помогает избежать дублирования и выражает свой функционал в понятной абстрактной манере. 

Например, такие типы как Array, Set и Dictionary используют дженерики для хранения элементов.

## Generic-функции
Универсальные функции могут работать с любыми типами.
Скажем, нам нужно создать массив, состоящий из значений целого типа и строк. Чтобы решить эту задачу, я создам две функции. Так же нужно вывести массив элементов типа float или массив пользовательских объектов. 

```swift
let intArray = [1, 2, 3, 4]
let stringArray = [a, b, c, d]
func printInts(array: [Int]) {
  print(intArray.map { $0 })
}
func printStrings(array: [String]) {
  print(stringArray.map { $0 })
}
```

Если мы посмотрим на функции выше, то увидим, что используется только разница в типе. Поэтому вместо того, чтобы дублировать код, мы можем написать generic-функцию для повторного использования.

```swift
func print<T>(array: [T]) {
  print(array.map { $0 })
}
```
Универсальный тип Т из примера выше – это параметр типа. Можно указать несколько параметров типа, записав несколько имен параметров типа в угловые скобки, разделив их запятыми.

## Generic-типы
Это пользовательские классы, структуры и перечисления, которые могут работать с любым типом, аналогично массивам и словарям.
Давайте создадим стек
```swift
struct Stack {
    var array: [Int] = []
    
    public mutating func push(element: Int) {
        array.append(element)
    }
    
    public mutating func pop() -> Int? {
        return array.popLast()
    }
}
```
Сейчас этот стек способен принимать только целочисленные элементы, и если мне понадобится хранить элементы другого типа, то нужно будет либо создавать другой стек, либо преобразовывать этот к generic виду.
```swift
struct Stack<Element> {
    var array: [Element] = []
    
    public mutating func push(element: Element) {
        array.append(element)
    }
    
    public mutating func pop() -> Element? {
        return array.popLast()
    }
}
```

Теперь этот объект может принимать любой тип данных

## Ограничения Generic-типов
Иногда полезно применять ограничения к типам, которые могут использоваться с generic-функциями или generic-типами. Ограничения типа указывают на то, что параметр типа должен соответствовать определенному протоколу или составу протокола.
Вы пишете ограничения типа, поместив ограничение единственного класса или протокола после имени параметра типа, и разделив их между собой запятыми, обозначая их в качестве части списка параметров.
```swift
func min<T: Comparable>(_ x: T, _ y: T) -> T {
       return y < x ? y : x
}
```
или
```swift
func min<T>(_ x: T, _ y: T) -> T where T: Comparable {
       return y < x ? y : x
}
```

