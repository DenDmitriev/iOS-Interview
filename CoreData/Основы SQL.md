# Основны SQL

### Содержание:
- [Индексы](url)
- [Основные операторы SQL](url)
- [Агрегатные функции](url)
- [Вопросы](url)

# Индексы
Indexes – это особые таблицы, используемые поисковыми системами для поиска данных. 
Их активное использование играет важнейшую роль в повышении производительности sql серверов. Благодаря индексу процесс поиска данных сокращается за счет их упорядочивания как физического, так и логического. Таким образом, таблица выглядит как набор ссылок на данные, которые упорядочены по выбранному столбцу таблицы. Такой столбец называется индексированным. Индексы находятся в таблице и по сути выступают полезными внутренними механизмами системы sql-сервера, которые помогают сделать доступ к данным наиболее оптимальным.

Используя значения, заданные первичным ключом, sql server найдет нужный индекс и с его помощью быстро выберет все строки с необходимыми данными. Если не использовать индекс, то для поиска информации будет произведено сканирование каждой строки таблицы. Это значительно понизит производительность и увеличит время поиска.

## Об индексах и кучах
Как только таблица создана и в ней еще нет индексов, она выглядит как куча данных (Heap). В ней все записи хранятся хаотично, без определенного порядка. Потому их и называют «кучами».

Если в таблице необходимо найти определенные данные, sql server просканирует ее (Table scan). Пока в таблице не заданы индексы, сервер прочитает все табличные записи (с первой до последней) и выберет те, которые удовлетворяют условиям поиска.

Но если мы укажем ограничения (UNIQUE CONSTRAINT, UNIQUE INDEX или PRIMARY KEY), то таблица станет индексирвоана и будем иметь примущества:

## Приемущества Indexes
- повышение скорости поиска информации и производительности запросов;
- сохранение целостности данных через обеспечение уникальности строк таблицы.

Но не всегда индекс помогает ускорить поиск информации. Для таблиц небольших размеров обычный перебор данных может оказаться намного эффективнее выборки данных по индексам.

## Недостатки Indexes
- требуется много места на дисковом пространстве и в оперативной памяти. Чем длиннее ключ, тем большего размера индекс и место для его хранения;
- замедляется производительность системы (медленнее выполняются операции вставок, обновления либо удаления записей).

## Структура Indexes
Все индексы имеют одинаковую структуру (structure). Они состоят из:
1. наборов страниц;
2. узлов, имеющих древовидную структуру, иерархическую по природе.

Все они хранятся в виде сбалансированных B-деревьев (B-tree). Начало такого дерева расположено в корневом узле (находящимся на вершине иерархии) и по сути является «входной дверью». Этот узел имеет одну страницу, в которой содержатся указатели на ключи последующих уровней.

![B+Tree](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/a690e4d9-4631-449c-bd6b-be0b11967cd8)

В нижней части иерархии расположены листья дерева (являющиеся конечными узлами). Длины веток одинаковы. 

В таком дереве сбалансирована каждая ветка. Благодаря внутреннему механизму при любых изменениях в таблице дерево снова становится сбалансированным.

При формировании запроса к индексированному столбцу подсистема начинает процесс поиска с верхнего узла к нижним, проходя промежуточные и обрабатывая их. На каждом уровне располагается все более развернутая информация о запрашиваемых данных. Как только достигается нижний уровень листьев (leaf level) поиск прекращается, т.к. подсистема запросов находит необходимое значение.

## Типы индексов
SQL Server используются следующие индексы: кластерные и некластерные. Рассмотрим их подробнее.

### Кластерный индекс
Индекс обеспечиваюший сохранение табличных данных в отсортированном виде по значению ключа. Таблице может быть присущ только один кластеризованный индекс (Clustered index), потому что табличные данные могут отсортировываться в едином возможном порядке – либо возрастания, либо убывания. По возможности, у каждой таблицы должен быть Clustered index.

#### Свойства Clustered index: 
- Табличные данные будут храниться отсортированными лишь в том случае, когда таблица имеет кластеризованный индекс.
- Строки табличных данных Clustered index хранит в уровнях листьев.
- Если у таблицы нет Clustered index, в момент формирования ограничений PRIMARY KEY и UNIQUE, он формируется автоматически.
- Когда для таблиц/куч созданы Nonclustered indexes, то в процессе создания Clustered index все некластеризованные должны быть перестроены.
- Содержание листьев зависит от того, индекс кластерный или некластерный. Они могут содержать как табличные данные, так и ссылки, указывающие на строки с ними.

### Некластерный индекс
Некластеризованными (Nonclustered) называют такие индексы, которые содержат:
- значения ключей – ключевые столбцы, по которым они определены;
- указатели на строки в таблице, содержащие реальные данные (значения ключа).

Чтобы обнаружить и получить запрашиваемые данные, для системы подзапросов потребуется совершение дополнительных операций. Содержимое указателей на запрашиваемые данные полностью зависит от того, как они хранятся.

Он может указывать на:
- кучу и тем самым приводить к идентификатору строки с искомыми данными;
- таблицу с Clustered index, указывая, что именно он используется что для поиска действительных данных.

Nonclustered indexes могут быть расширены дополнительными столбцами (included column). А значит, листья будут сохранять значения индексированных и дополнительных неиндексированных столбцов. Это свойство дает возможность обойти определенные ограничения, возложенные на индекс. Данный подход позволяет включать неиндексируемые столбцы либо обходить ограничения на длину индекса.

#### Свойства Nonclustered indexes:
- их нельзя отсортировать;
- на таблицу можно сформировать свыше одного (до 999) некластеризованных индексов. Но не стоит создавать максимальное количество Nonclustered indexes. Нужно помнить, что они способны как повысить, так и понизить производительность.
- Nonclustered indexes могут создаваться на любых таблицах, в том числе и имеющих кластерный индекс.

### Специальные типы индексов
Существует большое число специальных индексов, которые могут быть как кластерными, так и некластерными. Рассмотрим некоторые из них.

#### Фильтруемый
Фильтруемым (Filtered) индексом называют оптимизированный Nonclustered index, в котором задействован предикат фильтра для индексации части строк в таблице.

Тщательно спроектированный Filtered index способен:
- увеличить производительность;
- уменьшить затраты на обслуживание и хранение индексов.

#### Составной
Составным называют индекс, который:
- может включать более одного (до 16) столбцов, выступающих ключевыми значениями;
- ограничивается общей длиной (не превышающей 900 байт);
- содержит поля, которые принадлежат единой таблице.

Простые индексы, в отличие от составных, создаются лишь по единственному столбцу.

Создание составных индексов целесообразно, когда:
- для поискового запроса ключами выступают два и более столбцов;
- в поисковом запросе используются все поля составного индекса. Поисковый запрос, в котором не задействованы все поля, вероятнее всего, использоваться не будет.

Отличным примером может служить телефонный справочник. Он сформирован по фамилии и имени, т.к. много людей имеют одинаковую фамилию. Следовательно, логично будет создать индекс одновременно и по фамилии, и по имени.

Использование составных индексов поможет увеличить производительность за счет того, что для выполнения поиска данных сервер будет сканировать только его, что поможет снизить в таблице число индексов.

#### Уникальный
Уникальным (Unique) называют индекс, обеспечивающий уникальное значение всех строк по определенному ключу и гарантирующий, что в ключе индекса не будет значений одинаковых, повторяющихся. Для составного ключа понятие уникальности касается всех index columns, но не распространяется на каждый столбец в отдельности.

Если в таблице формируется Unique index одновременно по ряду столбцов, это означает, что абсолютно каждая вариация значений в ключе будет уникальной.

SQL сервером создается автоматически Unique index для ключевых столбцов при формировании ограничений UNIQUE либо PRIMARY KEY. Но он формируется лишь при выполнении условия отсутствия дублей в ключевых столбцах таблицы.

Уникальный индекс создается автоматом при определении ограничений столбца:
- первичным ключом (на один столбец либо сразу на несколько), при условии, что кластерный индекс ранее не создавался. В том случае, когда он все-таки уже создан, сервер создаст уникальный некластерный индекс по первичному ключу;
- ограничением на уникальность значений – сервером создается Unique Nonclustered index. Когда кластерный индекс не был сформирован заранее, есть возможность создания именно Unique Clustered index.

#### Колоночный
Колоночным (Columnstore) называют индекс, в котором данные хранятся в столбцах. Использование Columnstore indexes наиболее целесообразно применять для крупных хранилищ, т.к. они помогут:
- производительность запросов увеличить в несколько раз;
- размеры данных уменьшить (благодаря их сжатию).

#### Пространственный
Пространственным (Spatial) называют тип расширенного индекса, позволяющего индексировать столбцы с пространственными данными (представленные в типах Geography или Geometry). Spatial index позволяет наилучшим образом использовать определенные операции запросов относительно пространственных столбцов и может создаваться только для них.

Основное условие создания пространственного индекса – наличие PRIMARY KEY для таблиц.

#### Полнотекстовый
Полнотекстовые (Full-text) индексы применяются для повышения эффективности поиска определенных слов в строках, где данные представлены в символах.

Действия по созданию и обслуживанию Full-text indexes называются «заполнениями». Встречаются заполнения:
- полное – осуществляется SQL сервером после создания нового Full-text index. Размер таблицы влияет на затребованный объем ресурсов. При увеличении размера на операцию требуются ресурсы большего размера. Потому предусмотрена возможность откладывания этого процесса;
- основанное на отслеживании изменений – применяется для того, чтобы обслуживать Full-text index после полного заполнения (первоначального).

#### Покрывающий
Покрывающим (Covering) называют индекс, позволяющий на конкретный запрос получать запрашиваемую информацию в полном объеме с листьев индекса, не обращаясь к записям таблицы. А значит, в Covering index хранится достаточный объем данных для полноценного ответа на запрос. Потому нет необходимости обращаться к таблице.

Благодаря тому, что ответ можно получить без использования таблицы, покрывающие индексы быстрее остальных. Однако, они становятся достаточно большими, потому злоупотреблять ими не стоит.

####  XML-индекс
XML – специфический тип индекса, предназначенный для работы с данными в столбцах таблицы, представленными в соответствующем формате. Он делает более эффективной обработку поисковых запросов к ним.

Встречаются XML-indexes:
- первичные – индексируют, хранят в столбцах XML теги, пути, значения. Целесообразно создавать, когда таблица по первичному ключу имеет кластерный индекс;
- вторичные – создаются лишь для таблиц с первичным XML-index. Применяются для увеличения производительности системы по определенному типу обращения к XML-столбцам. Встречаются типы XML-indexes: PATH, VALUE, PROPERTY.

# Базы данных
При разработке плана стратегии по индексированию, необходимо придерживаться советов специалистов:
1. Если предполагается частое обновление данных в таблице, то для нее нужно применять минимум индексов.
2. Для таблицы со значительным количеством данных, которые предположительно будут редко изменяться, можно использовать то число индексов, которое улучшит производительность запросов. Но для таблиц небольшого объема не всегда целесообразно вообще их использовать. Такой поиск может выполняться дольше, чем обычное сканирование таблицы.
3. Для Clustered indexes используйте самые короткие поля, которые только допустимы. Лучше всего их применять на столбцах с уникальными значениями и в которых не допускается использование NULL. По этой причине чаще всего PRIMARY KEY выступает в роли Clustered index.
4. Производительность индекса напрямую зависит от того, насколько уникальны значения в столбце. Она снижается с увеличением дублей если в столбце и растет с уменьшением. Потому, при каждой возможности следует использовать уникальный индекс.
5. Если используется составной индекс, то в нем нужно учитывать порядок столбцов. Первыми идут те, в которых в выражениях используется WHERE. За ними – столбцы с наивысшими показателями уникальных значений. Остальные выстраиваются по мере понижения этого показателя.
6. Допускается использование индекса на вычисляемых столбцах таблицы, но лишь при условии соблюдения определенных требований (для вычисления значений такого столбца могут использоваться только детерминистические выражения, т.е. результат для определенного набора входящих параметров всегда должен быть одинаковым).

## Запросы к базе данных
При проектировании вторым важным пунктом является понимание и учет того, какие выполняются запросы к базе данных. Необходимо учитывать частоту изменения данных, а также требуется соблюдение определенных принципов:
- Предпочтительнее, чтобы один запрос содержал наибольшее число строк, нежели разбивать их на соответствующее число отдельных запросов.
- На столбцах, используемых в запросах с WHERE чаще всего, предпочтительнее создавать Nonclustered index в качестве условия поиска и соединения в JOIN.
- Следует воспользоваться возможностями индексирования столбцов, используемых в поисковых запросах на соответствие конкретным значениям.


# Основные операторы SQL

## Операторы работы с базой данных
### SHOW DATABASES
SQL-команда, которая отвечает за просмотр доступных баз данных.

### CREATE DATABASE
Команда для создания новой базы данных.

### USE
С помощью этой SQL-команды USE <database_name> выбирается база данных, необходимая для дальнейшей работы с ней.

### SOURCE
А SOURCE <file.sql> позволит выполнить сразу несколько SQL-команд, содержащихся в файле с расширением .sql.

### DROP DATABASE
Стандартная SQL-команда для удаления целой базы данных.

## Операторы работы с таблицей
### SHOW TABLES
С помощью этой несложной команды можно увидеть все таблицы, которые доступны в базе данных.

### CREATE TABLE
SQL-команда для создания новой таблицы.
Пример:
Создайте таблицу «instructor»:
```sql
CREATE TABLE instructor (
  ID CHAR(5),
  name VARCHAR(20) NOT NULL,
  dept_name VARCHAR(20),
  salary NUMERIC(8,2),
  PRIMARY KEY (ID),
  FOREIGN KEY (dept_name) REFERENCES department(dept_name)
);
```
Ограничения:
- ячейка таблицы не может иметь значение NULL;
- первичный ключ — PRIMARY KEY(col_name1, col_name2, …);
- внешний ключ — FOREIGN KEY(col_namex1, …, col_namexn) REFERENCES table_name(col_namex1, …, col_namexn).

### DESCRIBE
С помощью DESCRIBE <table_name> можно просмотреть различные сведения (тип значений, является ключом или нет) о столбцах таблицы.

### INSERT
Команда INSERT INTO <table_name> в SQL отвечает за добавление данных в таблицу:
```sql
INSERT INTO  (, , , …)
  VALUES (, , , …);
```

### UPDATE
SQL-команда для обновления данных таблицы:
```sql
UPDATE 
  SET  = ,  = , ...
  WHERE ;
```

### DELETE
SQL-команда DELETE FROM <table_name> используется для удаления данных из таблицы.

### DROP TABLE
А так можно удалить всю таблицу целиком.

## Операторы работы с данными
### SELECT
Для получения данных из выбранной таблицы:
```sql
SELECT , , …
  FROM ;
```

### SELECT DISTINCT
В столбцах таблицы могут содержаться повторяющиеся данные. Используйте SELECT DISTINCT для получения только неповторяющихся данных.
```sql
SELECT , , …
  FROM 
  WHERE ;
```

### WHERE
Можно использовать ключевое слово WHERE в SELECT для указания условий в запросе:
В запросе можно задавать следующие условия:
- сравнение текста;
- сравнение численных значений;
- логические операции AND (и), OR (или) и NOT (отрицание).

Пример
Попробуйте выполнить следующие команды. Обратите внимание на условия, заданные в WHERE:
```sql
SELECT * FROM course WHERE dept_name=’Comp. Sci.’;
SELECT * FROM course WHERE credits>3;
SELECT * FROM course WHERE dept_name='Comp. Sci.' AND credits>3;
```

### GROUP BY
Оператор GROUP BY часто используется с агрегатными функциями, такими как COUNT, MAX, MIN, SUM и AVG, для группировки выходных значений.
Пример
Выведем количество курсов для каждого факультета:
```sql
SELECT COUNT(course_id), dept_name
  FROM course
  GROUP BY dept_name;
```

### ORDER BY
ORDER BY используется для сортировки результатов запроса по убыванию или возрастанию. ORDER BY отсортирует по возрастанию, если не будет указан способ сортировки ASC или DESC.
```sql
SELECT , , …
  FROM 
  ORDER BY , , … ASC|DESC;
```
Пример
Выведем список курсов по возрастанию и убыванию количества кредитов:
```sql
SELECT * FROM course ORDER BY credits;
SELECT * FROM course ORDER BY credits DESC;
```

### BETWEEN
BETWEEN используется для выбора значений данных из определённого промежутка. Могут быть использованы числовые и текстовые значения, а также даты.
Пример
Выведем список инструкторов, чья зарплата больше 50 000, но меньше 100 000:
```sql
SELECT * FROM instructor
  WHERE salary BETWEEN 50000 AND 100000;
```

### LIKE
Оператор LIKE используется в WHERE, чтобы задать шаблон поиска похожего значения.
Есть два свободных оператора, которые используются в LIKE:
- % (ни одного, один или несколько символов);
- _ (один символ).

Пример
Выведем список курсов, в имени которых содержится «to», и список курсов, название которых начинается с «CS-»:
```sql
SELECT * FROM course WHERE title LIKE ‘%to%’;
SELECT * FROM course WHERE course_id LIKE 'CS-___';
```

### IN
С помощью IN можно указать несколько значений для оператора WHERE.
Пример
Выведем список студентов с направлений Comp. Sci., Physics и Elec. Eng.:
```sql
SELECT * FROM student
  WHERE dept_name IN (‘Comp. Sci.’, ‘Physics’, ‘Elec. Eng.’);
```

### JOIN
JOIN используется для связи двух или более таблиц с помощью общих атрибутов внутри них. На изображении ниже показаны различные способы объединения в SQL. Обратите внимание на разницу между левым внешним объединением и правым внешним объединением:

![13](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/4288859e-c102-4d0b-8b84-bca3207c67f7)

Пример
Выведем список всех обязательных курсов и детали о них:
```sql
SELECT prereq.course_id, title, dept_name, credits, prereq_id
  FROM prereq
  LEFT OUTER JOIN course
  ON prereq.course_id=course.course_id;
```

## Агрегатные функции
Это не совсем основные команды SQL, однако знать их тоже желательно. Агрегатные функции используются для получения совокупного результата, относящегося к рассматриваемым данным:
- COUNT(col_name) — возвращает количество строк;
- SUM(col_name) — возвращает сумму значений в данном столбце;
- AVG(col_name) — возвращает среднее значение данного столбца;
- MIN(col_name) — возвращает наименьшее значение данного столбца;
- MAX(col_name) — возвращает наибольшее значение данного столбца.


## Вопросы
### В чем отличия SQLite и SQL
SQL — язык запросов, с помощью которого специалисты отдают команды для управления базой данных.

SQLite — СУБД (Система управления базами данных), программное обеспечение, которое поддерживает этот язык. Человек, работающий с SQLite, будет использовать для обращения к базе язык запросов SQL. Но сама по себе СУБД намного шире, чем просто обертка для языка, и предоставляет множество других функций.

## Источники
- [Основные команды SQL, которые должен знать каждый программист](https://tproger.ru/translations/sql-recap)
- [Типы соединения](https://learndb.ru/articles/article/30)
- [Все, что необходимо знать про индексы MS SQL](https://otus.ru/journal/vse-chto-neobhodimo-znat-pro-indeksy-ms-sql/)
- [Связи между таблицами базы данных](https://habr.com/ru/articles/488054/)
- [Основные данные и Swift: параллелизм](https://coderlessons.com/articles/mobilnaia-razrabotka-articles/osnovnye-dannye-i-swift-parallelizm)
