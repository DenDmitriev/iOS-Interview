# Потокобезопасность
Потокобезопасность это когда вы можете читать и записывать значения из любого потока, не беспокоясь о синхронизации данных в разных местах приложения.

Сравним основные типы хранения на потокобезопасность:
| Тип хранения | Потокобезопасен |
| - | - |
| UserDefaults | ✔️ |
| KeyChain | ✔️ |
| CoreData | ❌ |

## Потокобезопасность в UserDefaults

## Потокобезопасность в KeyChain


## Потокобезопасность в CoreData
При работе с Core Data важно всегда помнить, что Core Data не является поточно-ориентированным. Базовые данные ожидают запуска в одном потоке. Это не означает, что каждая операция Core Data должна выполняться в главном потоке, что верно для UIKit, но это означает, что вам нужно помнить, какие операции выполняются с какими потоками. Это также означает, что вам нужно быть осторожным, как изменения из одного потока распространяются на другие потоки.

Работа с базовыми данными в нескольких потоках на самом деле очень проста с теоретической точки зрения. `NSManagedObject`, `NSManagedObjectContext` и `NSPersistentStoreCoordinator` не являются мультипоточными. Доступ к экземплярам этих классов возможен только из потока, в котором они были созданы. Как вы можете себе представить, это становится немного сложнее на практике.

### `NSManagedObject`
Мы уже знаем, что `NSManagedObject` не является потокобезопасным, но как получить доступ к записи из разных потоков? Экземпляр `NSManagedObject` имеет свойство `objectID` которое возвращает экземпляр класса `NSManagedObjectID`. Класс `NSManagedObjectID` является потокобезопасным, и экземпляр этого класса содержит всю информацию, которая необходима контексту управляемого объекта для извлечения соответствующего управляемого объекта.
```swift
// Object ID Managed Object
let objectID = managedObject.objectID
```
В следующем фрагменте кода мы запрашиваем контекст управляемого объекта для управляемого объекта, который соответствует `objectID`. `objectWithID(_:)` и `existingObjectWithID(_:)` возвращают локальную версию – локальную для текущего потока – соответствующего управляемого объекта.
```swift
// Fetch Managed Object
let managedObject = managedObjectContext.objectWithID(objectID)
 
// OR
 
do {
    let managedObject = try managedObjectContext.existingObjectWithID(objectID)
} catch {
    let fetchError = error as NSError
    print(“\(fetchError), \(fetchError.userInfo)”)
}
```
> Основное правило, которое нужно запомнить, – не передавать экземпляр NSManagedObject из одного потока в другой. Вместо этого передайте `objectID` управляемого объекта и запросите контекст управляемого объекта потока для локальной версии записи.

### `NSManagedObjectContext`
Поскольку класс `NSManagedObjectContext` не является потокобезопасным, мы могли бы создать контекст управляемого объекта для каждого потока, взаимодействующего с базовыми данными. Эта стратегия часто упоминается как ограничение потока.

Распространенным подходом является сохранение контекста управляемого объекта в словаре потока, словаре для хранения данных, специфичных для потока. Посмотрите на следующий пример, чтобы увидеть, как это работает на практике.
```swift
// Add Object to Thread Dictionary
let currentThread = NSThread.currentThread()
currentThread.threadDictionary.setObject(managedObjectContext, forKey: “managedObjectContext”)
```
Не так давно Apple рекомендовала такой подход. Даже при том, что это работает хорошо, есть еще один и лучший вариант, который Apple рекомендует сегодня. Мы рассмотрим этот вариант через несколько минут.

Как насчет постоянного координатора магазина? Вам нужно создать отдельный постоянный координатор хранилища для каждого потока. Хотя это возможно и является одной из стратегий, которые Apple рекомендовала, в этом нет необходимости.

Класс `NSPersistentStoreCoordinator` был разработан для поддержки нескольких контекстов управляемых объектов, даже если эти контексты управляемых объектов создавались в разных потоках. Поскольку класс `NSManagedObjectContext` блокирует координатор постоянного хранилища при доступе к нему, несколько контекстов управляемого объекта могут использовать один и тот же координатор постоянного хранилища, даже если эти контексты управляемого объекта живут в разных потоках. Это делает многопоточную настройку Core Data намного более управляемой и менее сложной.

### Стратегии параллелизма
Итак, мы узнали, что вам нужно несколько контекстов управляемых объектов, если вы выполняете операции Core Data в нескольких потоках. Однако предостережение заключается в том, что контексты управляемого объекта не знают о существовании друг друга. Изменения, вносимые в управляемый объект в одном контексте управляемого объекта, не распространяются автоматически в другие контексты управляемого объекта. Как мы решаем эту проблему?

Apple рекомендует использовать две популярные стратегии: 
1. Уведомления
2. контексты управляемых объектов «родитель-потомок». 

## Источники
- [CoreData и Swift: параллелизм](https://coderlessons.com/articles/mobilnaia-razrabotka-articles/osnovnye-dannye-i-swift-parallelizm)
