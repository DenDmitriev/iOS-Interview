# Side table

Side Table — механизм, с помощью которого реализуются слабые ссылки. Предствляет собой область в памяти, содержащая некоторую дополнительную информацию об объекте, которую не нужно хранить в нем самом. В ней хранятся счетчики ссылок. Не каждый объект содержит слабые ссылки, следовательно, и боковые таблицы, иначе это было бы расточительно. Вместо того чтобы напрямую указывать на объект, слабая ссылка указывает на боковую таблицу, которая, в свою очередь указывает на объект.

Первоначально объект содержит pointer и имеет только два счетчика ссылок strong и unowned. Боковой таблицы нет, ибо объект в ней никак не нуждается. При увеличении счетчика сильных ссылок всё работает как обычно, и ничего особенного не происходит.

![81d01b6920f5d497ad2f35f29775540f](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/527db48e-b033-46ca-be32-db90c11acb70)

Во втором поле резервируется один бит, по которому определяется, используется ли сейчас боковая таблица в этом поле или здесь хранится счетчик ссылок.

Как только мы начинаем ссылаться на объект слабо (weak reference), то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу. Сама боковая таблица также имеет ссылку на объект. 

![b482e8f80cd29ff43950e33b832d58e6](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/731931f4-1b2f-438e-9cab-db810767ff34)


Такое поведение решает две проблемы:
 - Экономия памяти, поскольку память объекта освобождается.
 - Наличие безопасного обнуления слабой ссылки, поскольку слабая ссылка теперь не указывает напрямую на объект и не является предметом race condition.

Боковая таблица — счетчик ссылок + указатель на объект и отображается в Swift Runtime следующим образом:

```C++
class HeapObjectSideTableEntry {
  std::atomic<HeapObject*> object;
  SideTableRefCounts refCounts;
  // Операции по увеличению и уменьшению счетчиков ссылок
}
```

# Жизненный цикл объекта Swift
**live → deiniting → deinited → freed → dead**
![f399867c0e27ed62e006d84c60a42223](https://github.com/DenDmitriev/iOS-Interview/assets/65191747/570dbc35-3fee-464a-8115-dedd5e0441db)

- На Live состоянии объект жив. Его счетчики ссылок выставлены по 1. Если есть указатель на слабую ссылку, то создается side table
- Когда strong RC достигает нуля, вызывается deinit(), и объект переходит в следующее состояние. Это состояние Deiniting. На данном этапе операции со strong ссылками не действуют. При чтении через unowned ссылку будет срабатывать assertion failure. Но новые unowned ссылки еще могут добавляться. Если есть боковая таблица, то weak операции будут возвращать nil. Далее из этого состояния уже можно перейти в два других.
   - Первое: если нет боковой таблицы (то есть нет weak ссылок) и нет unowned ссылок, то объект переходит в Dead состояние и сразу удаляется из памяти.
   - Второе: если у нас есть unowned или weak ссылки, объект переходит в состояние Deinited. В этом состоянии функция deinit() завершена. Сохранение и чтение сильных или слабых ссылок невозможно. Как и сохранение новых unowned ссылок. При попытке чтения unowned ссылки вызывается assertion failure. Из этого состояния также возможно два исхода.
- В том случае, если нет слабых ссылок, объект переходит непосредственно в состояние Dead, которое было описано выше.
- В случае наличия weak ссылок, а значит и боковой таблицы, осуществляется переход в состояние Freed (Освобожден). В Freed состоянии объект уже полностью освобожден и не занимает места в памяти, но его боковая таблица остается жива.
После того как счетчик слабых ссылок достигает нуля, боковая таблица также удаляется и освобождает память, и осуществляется переход в финальное состояние — Dead.
- В мертвом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на HeapObject освобождается из кучи, не оставляя следов объекта в памяти.

## Источники:
 - [iOS Interview](https://ios-interview.ru/side-table/)
 - [Память в Swift от 0 до 1](https://habr.com/ru/companies/hh/articles/546856/)
 - [Управление памятью в Swift](https://habr.com/ru/articles/592385/#)
