# Принципы разработки и проектирования
- [YAGNI](#yagni)
- [DRY / DIE / WET](#dry)
- [KISS](#kiss)
- [BDUF](#Bduf)
- [Avoid Premature Optimization](#avoid-premature-optimization)
- [Бритва Оккама](#бритва-оккама)
- [SOLID](#solid)

## YAGNI 
**You Aren’t Gonna Need It / Вам это не понадобится**

<img width="480" alt="YAGNI" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/d4292dd7-e123-4e88-a4e9-52f42730ad51">

Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже. Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.

## DRY 
**Don’t Repeat Yourself / Не повторяйся или Duplication Is Evil / Повторение это ад**

<img width="480" alt="DRY" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/85bb50f5-0610-4669-a589-e4934cc5b758">

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом. В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

## WET 
**Write Everything Twice / Пиши всё по дважды**
Нарушения принципа DRY: «Write Everything Twice» (Пиши всё по два раза) или «We enjoy typing» (Нам нравится печатать).

## KISS 
**Keep It Simple, Stupid / Будь проще**

<img width="480" alt="KISS" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/6e57d5e4-fd75-4cb0-ae57-0ef782da2d47">

Этот принцип гласит, что простые системы будут работать лучше и надежнее. Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется. Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно. Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.

## BDUF 
**Big Design Up Front / Глобальное проектирование прежде всего**

<img width="480" alt="BDUF" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/db644b82-480b-48eb-8aad-de663f8cc6ba">

Прежде чем переходить к реализации, убедитесь, что все хорошо продумано. Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив план, вы избавите себя от необходимости раз за разом начинать с нуля. Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех. Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть другого шанса справиться с этими ошибками.

## Avoid Premature Optimization 
**Избегайте преждевременной оптимизации**

<img width="480" alt="Avoid Premature Optimization " src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/02743853-c64b-4046-bd33-99a6a0f268d9">

Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана. Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок. Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости. Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок. Многие считают преждевременную оптимизацию корнем всех зол.

## Бритва Оккама

<img width="480" alt="Бритва Оккама" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/aea2af0f-0e1a-4220-ae51-476c0335f446">

Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

## SOLID
> SOLID (сокр. от англ. *Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion*) - акроним, введённый Майклом Фэзерсом для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов ООП и проектирования.
- [**S**](#Single-responsibility) – The Single Responsibility Principle – Принцип единственной ответственности
- [**О**](#Open-closed) – The Open Closed Principle – Принцип открытости/закрытости. 
- [**L**](#Liskov-substitution) – The Liskov Substitution Principle – Принцип подстановки Барбары Лисков
- [**I**](#Interface-segregation) – The Interface Segregation Principle – Принцип разделения интерфейса
- [**D**](#Dependency-inversion) – The Dependency Inversion Principle – Принцип инверсии зависимостей

### Single responsibility
**Принцип единственной ответственности**

<img width="480" alt="Single responsibility" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/919a99b1-c090-41e4-901a-d8b0b1eae688">

Модуль должен отвечать перед одним и только одним актором.
Под актором здесь понимается группа, состоящая из одного или нескольких лиц, желающих изменения поведения программного модуля. Для определения соответствия программного модуля принципу единственной ответственности не всегда достаточно изучения лишь кода этого модуля. Требуется изучить также как этот модуль используется во внешнем по отношению к нему коде. Иными словами, каждый актор определяет контекст использования модуля или, что тоже самое, набор сценариев использования модуля. Это может показаться неочевидным сразу, но каждый сценарий использования модуля отражает чьё-либо желание зафиксированное в коде.
Следующие приёмы позволяют соблюдать принцип единственной ответственности: разработка через тестирование, выделение класса, фасад, Proxy, DAO.

### Open-closed
**Принцип открытости / закрытости**

<img width="480" alt="Open-closed" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/c552a139-ba4e-48d2-b68b-acc7df062cfe">

Программные сущности должны быть:
- открыты для расширения: означает, что поведение сущности может быть расширено, путём создания новых типов сущностей.
- закрыты для изменения: в результате расширения поведения сущности, не должны вносится изменения в код, которые эти сущности использует.

### Liskov substitution
**Принцип подстановки Барбары Лисков**

<img width="480" alt="Open-closed" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/725a75d1-36a3-4d54-999d-cff323b1c9d9">

Даёт определение понятия замещения — если S является подтипом T, тогда объекты типа T в программе могут быть замещены объектами типа S без каких-либо изменений желательных свойств этой программы (например, корректность). Более простыми словами можно сказать, что поведение наследуемых классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа.

### Interface segregation
**Принцип разделения интерфейса**

<img width="480" alt="Interface segregation" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/5df39445-bba5-4c80-a6c3-3336a7752501">


Клиенты не должны зависеть от методов, которые они не используют
Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

### Dependency inversion
**Принцип инверсии зависимостей**

<img width="480" alt="Dependency inversion" src="https://github.com/DenDmitriev/iOS-Interview/assets/65191747/79d933a5-9fae-42d0-9730-590582e60465">


Принцип, используемый для уменьшения зависимостей в компьютерных программах.
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
